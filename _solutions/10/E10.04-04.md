---
title:       Exercise 10.4-4
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "rooted tree, left-child right-sibling, tree traversal"
description: "Write an O(n)-time procedure that prints all the keys of an arbitrary rooted tree with n nodes, where the tree is stored using the left-child, right-sibling representation."
---

> Write an $$O(n)$$-time procedure that prints all the keys of an arbitrary rooted tree with $$n$$ nodes, where the tree is stored using the left-child, right-sibling representation.

In the left-child, right-sibling representation, each node $$x$$ has two pointers: $$x.\textit{left-child}$$ (pointing to its leftmost child) and $$x.\textit{right-sibling}$$ (pointing to its next sibling to the right). To visit all nodes, we need to traverse both downward (to children) and sideways (to siblings).

{% capture code %}
PRINT-TREE-LCRS(T, x)
    if x != NIL
        print x.key
        // Print all descendants of this node
        PRINT-TREE-LCRS(T, x.left-child)
        // Print all siblings of this node
        PRINT-TREE-LCRS(T, x.right-sibling)
{% endcapture %}
{% include clrs_code.html %}

To print the entire tree, we call $$\textsc{Print-Tree-Lcrs}$$($$T$$, $$T.\textit{root}$$).

### How It Works

For each node $$x$$, we:
1. Print its key
2. Recursively print all nodes in the subtree rooted at $$x$$'s leftmost child (which includes all of $$x$$'s children via the sibling links)
3. Recursively print all nodes in the subtree rooted at $$x$$'s right sibling (and their descendants)

This effectively implements a depth-first traversal of the tree.

### Running Time

Each node is visited exactly once, and at each node we perform $$O(1)$$ work (printing the key and making two recursive calls). Therefore, the total running time is $$O(n)$$.

{% capture note %}
The left-child, right-sibling representation is clever because it allows us to represent an arbitrary tree (where nodes can have any number of children) using only two pointers per node, the same as a binary tree.

If we think about it, following $$\textit{left-child}$$ is like going "down" in the tree, and following $$\textit{right-sibling}$$ is like going "right" among siblings at the same level. The traversal pattern is very similar to a preorder traversal of a binary tree, where $$\textit{left-child}$$ plays the role of "left" and $$\textit{right-sibling}$$ plays the role of "right."
{% endcapture %}
{% include aside.html title='Connection to Binary Trees' %}
