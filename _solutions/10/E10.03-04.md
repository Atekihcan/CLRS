---
title:       Exercise 10.3-4
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "compact storage, memory management, paging, virtual memory"
description: "It is often desirable to keep all elements of a doubly linked list compact in storage, using, for example, the first m index locations in the multiple-array representation. (This is the case in a paged, virtual-memory computing environment.) Explain how to implement the procedures ALLOCATE-OBJECT and FREE-OBJECT so that the representation is compact. Assume that there are no pointers to elements of the linked list outside the list itself. (Hint: Use the array implementation of a stack.)"
---

> It is often desirable to keep all elements of a doubly linked list compact in storage, using, for example, the first $$m$$ index locations in the multiple-array representation. (This is the case in a paged, virtual-memory computing environment.) Explain how to implement the procedures $$\textsc{Allocate-Object}$$ and $$\textsc{Free-Object}$$ so that the representation is compact. Assume that there are no pointers to elements of the linked list outside the list itself. (Hint: Use the array implementation of a stack.)

Keeping the list compact means all active list elements occupy consecutive array positions (indices 1 through $$m$$), with no gaps. This is beneficial in virtual memory systems because it minimizes the number of pages needed to store the list.

The hint suggests using a stack, which means we can use a simple counter to track where the next free position is. We allocate from the end (growing toward higher indices) and maintain a "top" pointer indicating the next available position.

{% capture code %}
ALLOCATE-OBJECT()
    if top == arrays.length
        error "out of space"
    top = top + 1
    return top

FREE-OBJECT(x)
    // Move the object at position 'top' to position 'x'
    key[x] = key[top]
    next[x] = next[top]
    prev[x] = prev[top]
    // Update pointers that pointed to 'top'
    if next[top] != NIL
        prev[next[top]] = x
    if prev[top] != NIL
        next[prev[top]] = x
    // Update list head if necessary
    if L.head == top
        L.head = x
    top = top - 1
{% endcapture %}
{% include clrs_code.html %}

{% include ads.html %}

### How It Works

**$$\textsc{Allocate-Object}$$:** We increment $$\textit{top}$$ and return it. This allocates the next available position at the end of the compact region. This takes $$O(1)$$ time.

**$$\textsc{Free-Object}$$:** This is more complex. To keep the list compact, we need to fill the gap left by the freed object. We do this by moving the object currently at position $$\textit{top}$$ into position $$x$$ (copying its $$\textit{key}$$, $$\textit{next}$$, and $$\textit{prev}$$ values). Then we update all pointers that pointed to $$\textit{top}$$ to now point to $$x$$. Finally, we decrement $$\textit{top}$$. This takes $$O(1)$$ time because we only update a constant number of pointers.

The invariant is that indices 1 through $$\textit{top}$$ are occupied, and indices $$\textit{top} + 1$$ through $$n$$ are free.

{% capture note %}
This compact representation has trade-offs:

**Advantages:**
- Better locality of reference for virtual memory systems
- Fewer page faults when accessing list elements
- More cache-friendly

**Disadvantages:**
- Deletion requires moving an element and updating pointers (more complex than standard $$\textsc{Free-Object}$$)
- Cannot have external pointers to list elements (they would become invalid when objects move)

The assumption "no pointers to elements outside the list itself" is crucial. If external code held a pointer to the object at position $$\textit{top}$$, that pointer would become invalid after we move the object during a free operation.
{% endcapture %}
{% include aside.html title='Trade-offs of Compaction' %}
