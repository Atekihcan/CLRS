---
title:       Exercise 14.3-6
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "augmented data structure, min gap, dynamic set, red-black tree"
description: "Show how to maintain a dynamic set Q of numbers that supports the operation MIN-GAP, which gives the magnitude of the difference of the two closest numbers in Q. Make the operations INSERT, DELETE, SEARCH, and MIN-GAP as efficient as possible, and analyze their running times."
---

> Show how to maintain a dynamic set $$Q$$ of numbers that supports the operation $$\textsc{Min-Gap}$$, which gives the magnitude of the difference of the two closest numbers in $$Q$$. For example, if $$Q = \{1, 5, 9, 15, 18, 22\}$$, then $$\textsc{Min-Gap}(Q)$$ returns $$18 - 15 = 3$$, since 15 and 18 are the two closest numbers in $$Q$$. Make the operations $$\textsc{Insert}$$, $$\textsc{Delete}$$, $$\textsc{Search}$$, and $$\textsc{Min-Gap}$$ as efficient as possible, and analyze their running times.

The minimum gap is the smallest difference between consecutive elements in sorted order. We can maintain this efficiently using an augmented red-black tree.

{% include ads.html %}

### Data Structure

Use a red-black tree where each node $$x$$ stores:
- $$x.key$$: the value
- $$x.min\_gap$$: the minimum gap in the subtree rooted at $$x$$
- $$x.min$$: the minimum value in the subtree rooted at $$x$$
- $$x.max$$: the maximum value in the subtree rooted at $$x$$

### Computing Attributes from Children

For a node $$x$$ with left child $$l$$ and right child $$r$$:

$$\begin{align*}
x.min &= \begin{cases}
l.min & \text{if } l \neq T.nil \\
x.key & \text{if } l = T.nil
\end{cases} \\
x.max &= \begin{cases}
r.max & \text{if } r \neq T.nil \\
x.key & \text{if } r = T.nil
\end{cases}
\end{align*}$$

The minimum gap in $$x$$'s subtree is the minimum of:
1. The minimum gap in the left subtree ($$l.min\_gap$$)
2. The minimum gap in the right subtree ($$r.min\_gap$$)
3. The gap between $$x$$ and its inorder predecessor ($$x.key - l.max$$, if $$l \neq T.nil$$)
4. The gap between $$x$$ and its inorder successor ($$r.min - x.key$$, if $$r \neq T.nil$$)

In formula form:

$$x.min\_gap = \min \begin{cases}
l.min\_gap & \text{if } l \neq T.nil \\
r.min\_gap & \text{if } r \neq T.nil \\
x.key - l.max & \text{if } l \neq T.nil \\
r.min - x.key & \text{if } r \neq T.nil
\end{cases}$$

These attributes satisfy the conditions of Theorem 14.1 (each depends only on local information), so we can maintain them efficiently.

### Operations

**$$\textsc{Min-Gap}(Q)$$:** Return $$T.root.min\_gap$$ in $$O(1)$$ time.

**$$\textsc{Search}(Q, k)$$:** Standard red-black tree search in $$O(\lg n)$$ time.

**$$\textsc{Insert}(Q, k)$$:**
1. Insert $$k$$ using standard red-black tree insertion
2. Compute the new node's attributes: $$min = max = key$$, $$min\_gap = \infty$$
3. Walk up from the new node to the root, updating $$min$$, $$max$$, and $$min\_gap$$ attributes
4. During rotations, update affected nodes in $$O(1)$$ time

Total time: $$O(\lg n)$$

**$$\textsc{Delete}(Q, k)$$:**
1. Delete $$k$$ using standard red-black tree deletion
2. Walk up from the deleted node's original position to the root, updating attributes
3. During rotations, update affected nodes in $$O(1)$$ time

Total time: $$O(\lg n)$$

### Why This Works

The minimum gap in the entire set is computed incrementally as we build the tree. At each node, we consider gaps across that node (between its left and right subtrees) and combine with the minimum gaps within each subtree. By Theorem 14.1, this can be maintained during insertions and deletions.

### Example

For $$Q = \{1, 5, 9, 15, 18, 22\}$$:
- At node 15, $$l.max = 9$$, $$r.min = 18$$
- Gap to left: $$15 - 9 = 6$$
- Gap to right: $$18 - 15 = 3$$
- $$15.min\_gap = \min(3, 6, l.min\_gap, r.min\_gap) = 3$$
- Root's $$min\_gap$$ would be 3, the answer

All operations run in $$O(\lg n)$$ time except $$\textsc{Min-Gap}$$, which runs in $$O(1)$$ time.
