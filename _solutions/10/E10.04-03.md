---
title:       Exercise 10.4-3
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "binary tree, iterative traversal, stack, tree printing"
description: "Write an O(n)-time nonrecursive procedure that, given an n-node binary tree, prints out the key of each node in the tree. Use a stack as an auxiliary data structure."
---

> Write an $$O(n)$$-time nonrecursive procedure that, given an $$n$$-node binary tree, prints out the key of each node in the tree. Use a stack as an auxiliary data structure.

Recursion implicitly uses the call stack to remember which nodes to visit next. We can make this explicit by using our own stack data structure. We'll implement an iterative preorder traversal.

{% capture code %}
PRINT-TREE-ITERATIVE(T)
    if T.root == NIL
        return
    let S be a new stack
    PUSH(S, T.root)
    while not STACK-EMPTY(S)
        x = POP(S)
        print x.key
        // Push right child first (so left is processed first)
        if x.right != NIL
            PUSH(S, x.right)
        if x.left != NIL
            PUSH(S, x.left)
{% endcapture %}
{% include clrs_code.html %}

{% include ads.html %}

### How It Works

We use a stack to keep track of nodes we need to visit. We start by pushing the root onto the stack. Then, in each iteration:

1. Pop a node from the stack
2. Print its key
3. Push its right child (if it exists)
4. Push its left child (if it exists)

We push the right child before the left child because stacks are LIFO (last in, first out). This ensures that the left child is popped (and thus processed) before the right child, giving us a preorder traversal.

### Running Time

Each of the $$n$$ nodes is pushed onto and popped from the stack exactly once. Each push and pop operation takes $$O(1)$$ time. Therefore, the total running time is $$O(n)$$.

The space complexity is $$O(h)$$ where $$h$$ is the height of the tree, since at most $$h$$ nodes can be on the stack at any time (one for each level from the current node to the root). In the worst case, $$h = n$$ for a completely unbalanced tree.

{% capture note %}
For an inorder traversal (which is more complex iteratively), we would need to go as far left as possible before printing, then process the right subtree:

```
let S be a new stack
current = T.root
while not STACK-EMPTY(S) or current != NIL
    if current != NIL
        PUSH(S, current)
        current = current.left
    else
        current = POP(S)
        print current.key
        current = current.right
```

The preorder version (shown above) is simpler and more intuitive.
{% endcapture %}
{% include aside.html title='Iterative Inorder Traversal' %}
