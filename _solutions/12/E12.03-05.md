---
title:       Exercise 12.3-5
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, successor pointer, parent pointer, tree operations"
description: "Suppose that instead of each node x keeping the attribute x.p, pointing to x's parent, it keeps x.succ, pointing to x's successor. Give pseudocode for SEARCH, INSERT, and DELETE on a binary search tree T using this representation. These procedures should operate in time O(h), where h is the height of the tree T."
---

> Suppose that instead of each node $$x$$ keeping the attribute $$x.p$$, pointing to $$x$$'s parent, it keeps $$x.\textit{succ}$$, pointing to $$x$$'s successor. Give pseudocode for $$\textsc{Search}$$, $$\textsc{Insert}$$, and $$\textsc{Delete}$$ on a binary search tree $$T$$ using this representation. These procedures should operate in time $$O(h)$$, where $$h$$ is the height of the tree $$T$$. (*Hint:* You may wish to implement a subroutine that returns the parent of a node.)

With successor pointers instead of parent pointers, we need to implement operations differently. The hint suggests implementing a parent-finding subroutine. Let us start with that.

### Finding the Parent

To find the parent of a node $$x$$, we search for $$x$$ from the root, keeping track of the previous node:

{% capture code %}
FindParent(T, x)
    return FindParentHelper(T.root, x, NIL)

FindParentHelper(y, x, parent)
    if y == NIL or y == x
        return parent
    if x.key < y.key
        return FindParentHelper(y.left, x, y)
    else
        return FindParentHelper(y.right, x, y)
{% endcapture %}
{% include clrs_code.html title='FindParent(T, x)' %}

This takes $$O(h)$$ time as it traverses a path from root to $$x$$.

### Search

Search does not use parent pointers, so it remains unchanged:

{% capture code %}
TreeSearch(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TreeSearch(x.left, k)
    else
        return TreeSearch(x.right, k)
{% endcapture %}
{% include clrs_code.html title='TreeSearch(x, k)' %}

Time: $$O(h)$$

### Insert

For insertion, we need to find the parent of the insertion position, insert the node, and update successor pointers. When we insert node $$z$$:

1. The old successor of $$z$$'s predecessor must now point to $$z$$
2. Node $$z$$'s successor must be set appropriately

{% capture code %}
TreeInsert(T, z)
    y = NIL
    x = T.root
    // Find insertion position
    while x ≠ NIL
        y = x
        if z.key < x.key
            x = x.left
        else
            x = x.right

    // Insert z as child of y
    if y == NIL
        T.root = z  // Tree was empty
        z.succ = NIL
    elseif z.key < y.key
        y.left = z
        // z's successor is y
        // y's predecessor's successor should now be z
        pred = FindPredecessor(T, y)
        if pred ≠ NIL
            pred.succ = z
        z.succ = y
    else
        y.right = z
        // z's successor is y's successor
        z.succ = y.succ
        y.succ = z

{% include ads.html %}

FindPredecessor(T, x)
    if x.left ≠ NIL
        return TreeMaximum(x.left)
    // Need to find predecessor by searching
    // This is complex without parent pointers
    // We can search from root finding largest node < x.key
    return FindPredFromRoot(T.root, x, NIL)

FindPredFromRoot(y, x, pred)
    if y == NIL
        return pred
    if y.key < x.key
        return FindPredFromRoot(y.right, x, y)
    else
        return FindPredFromRoot(y.left, x, pred)
{% endcapture %}
{% include clrs_code.html title='TreeInsert(T, z)' %}

Time: $$O(h)$$ for finding position, $$O(h)$$ for finding predecessor, total $$O(h)$$

### Delete

Deletion is more complex. We need to handle updating successor pointers when splicing out nodes:

{% capture code %}
TreeDelete(T, z)
    parent = FindParent(T, z)

    if z.left == NIL
        Transplant(T, z, z.right, parent)
        UpdateSuccessors(T, z)
    elseif z.right == NIL
        Transplant(T, z, z.left, parent)
        UpdateSuccessors(T, z)
    else
        y = TreeMinimum(z.right)
        y_parent = FindParent(T, y)
        if y_parent ≠ z
            Transplant(T, y, y.right, y_parent)
            y.right = z.right
        Transplant(T, z, y, parent)
        y.left = z.left
        UpdateSuccessors(T, z)

Transplant(T, u, v, u_parent)
    if u_parent == NIL
        T.root = v
    elseif u == u_parent.left
        u_parent.left = v
    else
        u_parent.right = v

UpdateSuccessors(T, deleted_node)
    // Find predecessor of deleted node
    pred = FindPredecessorOfDeleted(T, deleted_node.key)
    if pred ≠ NIL
        pred.succ = deleted_node.succ

FindPredecessorOfDeleted(T, key)
    // Find largest node with key < deleted key
    return FindLargestLessThan(T.root, key, NIL)

FindLargestLessThan(x, key, best)
    if x == NIL
        return best
    if x.key < key
        return FindLargestLessThan(x.right, key, x)
    else
        return FindLargestLessThan(x.left, key, best)
{% endcapture %}
{% include clrs_code.html title='TreeDelete(T, z)' %}

Time: $$O(h)$$ for each operation (finding parent, transplanting, updating successors)

{% capture note %}
This representation is less efficient than using parent pointers because:

1. Finding a parent requires searching from the root ($$O(h)$$ time)
2. Updating successor pointers requires finding predecessors, which also takes $$O(h)$$ without parent pointers
3. The constant factors are larger due to multiple tree traversals

While all operations maintain $$O(h)$$ time complexity, the practical performance is worse. Parent pointers allow direct access to ancestors, while successor pointers only help with inorder traversal.
{% endcapture %}
{% include aside.html title='Why parent pointers are preferred' %}
