---
title:       Exercise 12.2-9
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, leaf node, parent key"
description: "Let T be a binary search tree whose keys are distinct, let x be a leaf node, and let y be its parent. Show that y.key is either the smallest key in T larger than x.key or the largest key in T smaller than x.key."
---

> Let $$T$$ be a binary search tree whose keys are distinct, let $$x$$ be a leaf node, and let $$y$$ be its parent. Show that $$y.\textit{key}$$ is either the smallest key in $$T$$ larger than $$x.\textit{key}$$ or the largest key in $$T$$ smaller than $$x.\textit{key}$$.

Since $$y$$ is the parent of leaf $$x$$, we know that $$x$$ is either the left child or right child of $$y$$. We'll show that in each case, $$y$$ is either the successor or predecessor of $$x$$.

### Case 1: $$x$$ is the left child of $$y$$ (i.e., $$x = y.\textit{left}$$)

By the BST property, $$x.\textit{key} < y.\textit{key}$$.

Since $$x$$ is a leaf, $$x.\textit{right} = \textsc{Nil}$$. To find the successor of $$x$$, we use $$\textsc{Tree-Successor}$$:

- Since $$x.\textit{right} = \textsc{Nil}$$, we go to Case 2 of the algorithm
- We walk up from $$x$$ to its parent $$y$$
- Since $$x = y.\textit{left}$$, we have $$x \ne y.\textit{right}$$
- The while loop condition fails immediately, and we return $$y$$

Therefore, $$y = \textsc{Tree-Successor}(x)$$, which means $$y.\textit{key}$$ is the smallest key in $$T$$ larger than $$x.\textit{key}$$.

### Case 2: $$x$$ is the right child of $$y$$ (i.e., $$x = y.\textit{right}$$)

By the BST property, $$x.\textit{key} > y.\textit{key}$$.

Since $$x$$ is a leaf, $$x.\textit{left} = \textsc{Nil}$$. To find the predecessor of $$x$$, we use $$\textsc{Tree-Predecessor}$$:

- Since $$x.\textit{left} = \textsc{Nil}$$, we go to Case 2 of the algorithm
- We walk up from $$x$$ to its parent $$y$$
- Since $$x = y.\textit{right}$$, we have $$x \ne y.\textit{left}$$
- The while loop condition fails immediately, and we return $$y$$

Therefore, $$y = \textsc{Tree-Predecessor}(x)$$, which means $$y.\textit{key}$$ is the largest key in $$T$$ smaller than $$x.\textit{key}$$.

### Summary

In both cases, the parent $$y$$ of a leaf $$x$$ is either the successor or predecessor of $$x$$:

- If $$x$$ is a left child, then $$y$$ is the successor of $$x$$
- If $$x$$ is a right child, then $$y$$ is the predecessor of $$x$$

This makes intuitive sense: a leaf has no descendants, so its successor/predecessor must be an ancestor. Since it's a leaf, the closest ancestor (its parent) is the successor or predecessor.

### Example

Consider this tree:

```
        15
       /  \
      6   18
     / \  / \
    3   7 17 20
   / \
  2   4
```

- Leaf 2 is the left child of 3. Indeed, $$\textsc{Tree-Successor}(2) = 3$$ ✓
- Leaf 4 is the right child of 3. Indeed, $$\textsc{Tree-Predecessor}(4) = 3$$ ✓
- Leaf 7 is the right child of 6. Indeed, $$\textsc{Tree-Predecessor}(7) = 6$$ ✓
- Leaf 17 is the left child of 18. Indeed, $$\textsc{Tree-Successor}(17) = 18$$ ✓
- Leaf 20 is the right child of 18. Indeed, $$\textsc{Tree-Predecessor}(20) = 18$$ ✓

{% capture note %}
This property highlights a special relationship between leaves and their parents in a BST. Unlike internal nodes (which might have successors in their right subtree or predecessors in their left subtree), leaves always have their successor or predecessor as their immediate parent.

This is useful when implementing deletion: if we're deleting a node that happens to be a leaf, we know exactly where its successor/predecessor is located.
{% endcapture %}
{% include aside.html title='Leaves and their parents' %}
