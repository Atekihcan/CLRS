---
title:       Exercise 11.1-2
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "bit vector, direct address table, space efficiency"
description: "A bit vector is simply an array of bits (0s and 1s). A bit vector of length m takes much less space than an array of m pointers. Describe how to use a bit vector to represent a dynamic set of distinct elements with no satellite data. Dictionary operations should run in O(1) time."
---

> A **bit vector** is simply an array of bits (0s and 1s). A bit vector of length $$m$$ takes much less space than an array of $$m$$ pointers. Describe how to use a bit vector to represent a dynamic set of distinct elements with no satellite data. Dictionary operations should run in $$O(1)$$ time.

A bit vector provides an extremely space-efficient implementation of a direct-address table when we have distinct integer keys from a universe $$U = \{0, 1, \ldots, m-1\}$$ and no satellite data to store. Instead of storing pointers or full elements, we simply use one bit per possible key value.

The representation is simple. Let $$B[0 \ldots m-1]$$ be a bit vector where $$B[k] = 1$$ if key $$k$$ is in the set, and $$B[k] = 0$$ if key $$k$$ is not in the set. This requires only $$m$$ bits of storage, which is $$m/w$$ words on a machine with $$w$$-bit words (typically $$w = 32$$ or $$w = 64$$). In contrast, a standard direct-address table would require $$m$$ pointers or $$m$$ full object slots.

The dictionary operations are implemented using simple bit operations:

{% capture code %}
BitVectorSearch(B, k)
    return B[k]

BitVectorInsert(B, k)
    B[k] = 1

BitVectorDelete(B, k)
    B[k] = 0
{% endcapture %}
{% include clrs_code.html title="Bit Vector Operations" %}

Each operation performs a single array access, which takes $$O(1)$$ time. The $$\textsc{Search}$$ operation returns 1 if the key is present and 0 otherwise. $$\textsc{Insert}$$ sets the corresponding bit to 1, and $$\textsc{Delete}$$ sets it to 0.

The space savings can be substantial. For example, on a 64-bit machine where pointers are 8 bytes (64 bits), a standard direct-address table for $$m = 1000$$ keys would require 8000 bytes, while a bit vector requires only 125 bytes (1000 bits รท 8 bits/byte). This is a 64-fold reduction in space.

{% capture note %}
**Practical Considerations**

Bit vectors are widely used in practice for representing sets when:

1. The universe size $$m$$ is not too large
2. Elements have no associated satellite data
3. Space efficiency is important

Common applications include:
- **Bloom filters** for approximate set membership
- **Sieve of Eratosthenes** for finding prime numbers
- **Network routing tables** for fast packet filtering
- **Database indices** for marking valid record IDs
{% endcapture %}
{% include aside.html title='Why Bit Vectors Matter' %}
