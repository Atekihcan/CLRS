---
title:       Exercise 10.2-8
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "XOR linked list, space optimization, doubly linked list"
description: "Explain how to implement doubly linked lists using only one pointer value x.np per item instead of the usual two (next and prev). Assume that all pointer values can be interpreted as k-bit integers, and define x.np to be x.np = x.next XOR x.prev, the k-bit exclusive-or of x.next and x.prev. (The value NIL is represented by 0.) Be sure to describe what information you need to access the head of the list. Show how to implement the SEARCH, INSERT, and DELETE operations on such a list. Also show how to reverse such a list in O(1) time."
---

> Explain how to implement doubly linked lists using only one pointer value $$x.\textit{np}$$ per item instead of the usual two ($$\textit{next}$$ and $$\textit{prev}$$). Assume that all pointer values can be interpreted as $$k$$-bit integers, and define $$x.\textit{np}$$ to be $$x.\textit{np} = x.\textit{next}$$ $$\textsc{Xor}$$ $$x.\textit{prev}$$, the $$k$$-bit "exclusive-or" of $$x.\textit{next}$$ and $$x.\textit{prev}$$. (The value $$\textsc{Nil}$$ is represented by 0.) Be sure to describe what information you need to access the head of the list. Show how to implement the $$\textsc{Search}$$, $$\textsc{Insert}$$, and $$\textsc{Delete}$$ operations on such a list. Also show how to reverse such a list in $$O(1)$$ time.

This clever representation exploits a property of $$\textsc{Xor}$$: if $$a \oplus b = c$$, then $$a \oplus c = b$$ and $$b \oplus c = a$$. By storing $$x.\textit{np} = x.\textit{next} \oplus x.\textit{prev}$$, we can recover either pointer if we know the other.

### Accessing the List

To traverse the list, we need to know both the head and what comes before it (which is $$\textsc{Nil}$$). At the head node $$h$$, we have $$h.\textit{np} = h.\textit{next} \oplus 0 = h.\textit{next}$$. Similarly, at the tail node $$t$$, we have $$t.\textit{np} = 0 \oplus t.\textit{prev} = t.\textit{prev}$$.

To maintain the list, we store:
- $$L.\textit{head}$$: pointer to the first node
- $$L.\textit{tail}$$: pointer to the last node

### Traversal

To traverse from node $$x$$ to the next node, we need to know the previous node $$p$$:

$$\begin{align*}
x.\textit{next} &= p \oplus x.\textit{np} \\
&= p \oplus (x.\textit{next} \oplus x.\textit{prev}) \\
&= p \oplus x.\textit{next} \oplus p \quad \text{(since } p = x.\textit{prev}\text{)} \\
&= x.\textit{next}
\end{align*}$$

{% capture code %}
XOR-LIST-SEARCH(L, k)
    prev = NIL
    x = L.head
    while x != NIL
        if x.key == k
            return x
        next = prev XOR x.np
        prev = x
        x = next
    return NIL
{% endcapture %}
{% include clrs_code.html %}

### Insertion at Head

{% capture code %}
XOR-LIST-INSERT(L, x)
    x.np = NIL XOR L.head
    if L.head != NIL
        L.head.np = (L.head.np XOR NIL) XOR x
    else
        L.tail = x
    L.head = x
{% endcapture %}
{% include clrs_code.html %}

### Deletion

To delete node $$x$$, we need pointers to both its predecessor $$p$$ and successor $$n$$:

{% capture code %}
XOR-LIST-DELETE(L, x, prev)
    // Get next node
    next = prev XOR x.np
    // Update predecessor's np
    if prev != NIL
        prev.np = (prev.np XOR x) XOR next
    else
        L.head = next
    // Update successor's np
    if next != NIL
        next.np = (next.np XOR x) XOR prev
    else
        L.tail = prev
{% endcapture %}
{% include clrs_code.html %}

### Reversing in $$O(1)$$ Time

This is remarkably simple: just swap $$L.\textit{head}$$ and $$L.\textit{tail}$$!

{% capture code %}
XOR-LIST-REVERSE(L)
    swap L.head with L.tail
{% endcapture %}
{% include clrs_code.html %}

This works because the $$\textit{np}$$ values don't need to change. When we traverse from what was the tail (now the head), we use $$\textsc{Nil}$$ as the "previous" pointer, which gives us the correct next node in the reversed direction.

### Complexity

- $$\textsc{Search}$$: $$\Theta(n)$$ worst case
- $$\textsc{Insert}$$: $$O(1)$$ at head or tail
- $$\textsc{Delete}$$: $$O(1)$$ if we have both the node and its predecessor
- $$\textsc{Reverse}$$: $$O(1)$$

{% capture note %}
While this XOR linked list saves one pointer per node, it has significant practical drawbacks:

1. We cannot traverse backward from an arbitrary node without additional information.
2. Debugging is more difficult (we can't easily inspect pointers).
3. Garbage collection is complicated (we can't determine what a node points to without context).
4. The savings (one pointer per node) may not be worth the added complexity in most applications.

This technique is primarily of theoretical interest, though it has been used in memory-constrained embedded systems.
{% endcapture %}
{% include aside.html title='Practical Considerations' %}
