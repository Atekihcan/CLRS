---
title:       Exercise 10.4-2
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "binary tree, recursive traversal, tree printing"
description: "Write an O(n)-time recursive procedure that, given an n-node binary tree, prints out the key of each node in the tree."
---

> Write an $$O(n)$$-time recursive procedure that, given an $$n$$-node binary tree, prints out the key of each node in the tree.

A simple recursive procedure can traverse the entire tree and print each node's key. We'll use a preorder traversal (print the current node, then recursively visit the left subtree, then the right subtree).

{% capture code %}
PRINT-TREE(T, x)
    if x != NIL
        print x.key
        PRINT-TREE(T, x.left)
        PRINT-TREE(T, x.right)
{% endcapture %}
{% include clrs_code.html %}

To print the entire tree, we call $$\textsc{Print-Tree}$$($$T$$, $$T.\textit{root}$$).

### Running Time

The procedure visits each node exactly once. At each node, it performs $$O(1)$$ work (printing the key and making two recursive calls). Therefore, the total running time is $$O(n)$$ for an $$n$$-node tree.

The recursion depth is bounded by the height of the tree, which is at most $$n$$ (in the case of a completely unbalanced tree). For a balanced tree, the height is $$O(\log n)$$.

{% capture note %}
We could also use inorder traversal (left, root, right) or postorder traversal (left, right, root) depending on the desired order of output. For a binary search tree, inorder traversal would print the keys in sorted order.

**Inorder:**
```
if x != NIL
    PRINT-TREE(T, x.left)
    print x.key
    PRINT-TREE(T, x.right)
```

**Postorder:**
```
if x != NIL
    PRINT-TREE(T, x.left)
    PRINT-TREE(T, x.right)
    print x.key
```

All three traversals take $$O(n)$$ time.
{% endcapture %}
{% include aside.html title='Alternative Traversal Orders' %}
