---
title:       Exercise 10.1-4
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "queues, underflow, overflow, error detection"
description: "Rewrite ENQUEUE and DEQUEUE to detect underflow and overflow of a queue."
---

> Rewrite $$\textsc{Enqueue}$$ and $$\textsc{Dequeue}$$ to detect underflow and overflow of a queue.

The queue presented in the text doesn't check for underflow or overflow conditions. We need to add these checks to make the implementation more robust.

For underflow, we need to detect when we try to dequeue from an empty queue. A queue is empty when $$Q.\textit{head} = Q.\textit{tail}$$.

For overflow, we need to detect when the queue is full. The queue becomes full when the tail pointer wraps around and would overwrite the head element. This happens when incrementing the tail (with wraparound) makes it equal to the head, which means $$Q.\textit{head} = Q.\textit{tail} + 1$$ (with wraparound), or when both are at position 1 and $$n$$ respectively.

{% capture code %}
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.length
        Q.tail = 1
    else
        Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    if Q.head == Q.tail
        error "underflow"
    x = Q[Q.head]
    if Q.head == Q.length
        Q.head = 1
    else
        Q.head = Q.head + 1
    return x
{% endcapture %}
{% include clrs_code.html %}

{% capture note %}
The overflow check comes after we've updated the tail pointer in $$\textsc{Enqueue}$$. This is because the queue structure in the text wastes one array slot to distinguish between empty and full states. When $$Q.\textit{head} = Q.\textit{tail}$$, the queue is empty. The queue is full when the next insertion would make $$Q.\textit{tail} = Q.\textit{head}$$.

This means an array of length $$n$$ can hold at most $$n - 1$$ elements, which is why the text states the queue can hold "at most $$n - 1$$ elements."
{% endcapture %}
{% include aside.html title='Why One Slot is Wasted' %}
