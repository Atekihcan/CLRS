---
title:       Exercise 11.1-4
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "direct address table, huge array, garbage initialization, auxiliary array"
description: "We wish to implement a dictionary by using direct addressing on a huge array. At the start, the array entries may contain garbage, and initializing the entire array is impractical because of its size. Describe a scheme for implementing a direct-address dictionary on a huge array. Each stored object should use O(1) space; the operations SEARCH, INSERT, and DELETE should take O(1) time each; and initializing the data structure should take O(1) time."
---

> We wish to implement a dictionary by using direct addressing on a huge array. At the start, the array entries may contain garbage, and initializing the entire array is impractical because of its size. Describe a scheme for implementing a direct-address dictionary on a huge array. Each stored object should use $$O(1)$$ space; the operations $$\textsc{Search}$$, $$\textsc{Insert}$$, and $$\textsc{Delete}$$ should take $$O(1)$$ time each; and initializing the data structure should take $$O(1)$$ time. (Hint: Use an additional array, treated somewhat like a stack whose size is the number of keys actually stored in the dictionary, to help determine whether a given entry in the huge array is valid or not.)

The challenge here is that we have a huge array $$T[0 \ldots m-1]$$ where $$m$$ is very large, making it impractical to initialize all entries to $$\textsc{Nil}$$. Initially, the array contains arbitrary garbage values. We need a way to distinguish valid entries from garbage without scanning the entire array.

The solution uses two auxiliary arrays to validate entries. We maintain a stack array $$S[1 \ldots n]$$ that stores the keys of all elements currently in the dictionary (where $$n \leq m$$ is the number of stored keys), and we use $$T$$ itself to store back-pointers into $$S$$. This creates a two-way verification system.

**Data Structure:**
1. $$T[0 \ldots m-1]$$: huge direct-address table where $$T[k].element$$ stores the element with key $$k$$, and $$T[k].index$$ stores the position of key $$k$$ in array $$S$$
2. $$S[1 \ldots n]$$: stack of keys actually stored, where $$S[i]$$ is the $$i$$-th key inserted
3. $$top$$: count of elements in the dictionary (size of stack $$S$$)

**Validity Check:**
Key $$k$$ is valid if and only if:
1. $$1 \leq T[k].index \leq top$$ (the index is in range)
2. $$S[T[k].index] = k$$ (the back-reference is correct)

This two-way validation ensures we never mistake garbage for valid data. If $$T[k]$$ contains garbage, then either $$T[k].index$$ will be out of range, or $$S[T[k].index]$$ won't equal $$k$$.

{% capture code %}
InitializeDict()
    top = 0

Search(T, k)
    if 1 ≤ T[k].index ≤ top and S[T[k].index] = k
        return T[k].element
    else
        return NIL

Insert(T, x)
    k = x.key
    if Search(T, k) ≠ NIL
        return  // key already exists
    top = top + 1
    S[top] = k
    T[k].element = x
    T[k].index = top

Delete(T, x)
    k = x.key
    if Search(T, k) = NIL
        return  // key not in table
    i = T[k].index
    // Move last key in S to position i
    S[i] = S[top]
    T[S[top]].index = i
    top = top - 1
{% endcapture %}
{% include clrs_code.html title="Huge Array Direct Addressing" %}

**Analysis:**

Initialization takes $$O(1)$$ time since we only set $$top = 0$$, leaving the arrays uninitialized.

$$\textsc{Search}$$ takes $$O(1)$$ time: we check if $$T[k].index$$ is in the valid range and verify the back-reference $$S[T[k].index] = k$$, then return the element if valid.

$$\textsc{Insert}$$ takes $$O(1)$$ time: we increment $$top$$, add $$k$$ to $$S[top]$$, store the element at $$T[k].element$$, and set $$T[k].index = top$$ to complete the two-way link.

$$\textsc{Delete}$$ takes $$O(1)$$ time: we move the last key in $$S$$ to fill the gap left by the deleted key, update its index in $$T$$, and decrement $$top$$. This maintains the compact stack property without creating holes.

Space per element is $$O(1)$$: each element uses one slot in $$T$$ (storing the element and an integer index) plus one slot in $$S$$ (storing the key).

{% capture note %}
**Why This Works**

The key insight is that valid entries have a consistent two-way relationship: $$T[k]$$ points to a position $$i$$ in $$S$$, and $$S[i]$$ points back to $$k$$. Garbage values in $$T$$ will almost certainly fail one of these checks:
- Either $$T[k].index$$ is out of range $$[1, top]$$, or
- $$S[T[k].index]$$ contains a different key

This technique is sometimes called a "sparse array" or "dictionary of keys" and is used in practice for situations like implementing sparse matrices or managing large address spaces with few actual allocations.
{% endcapture %}
{% include aside.html title='The Power of Two-Way Verification' %}
