---
title:       Exercise 14.3-7
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "VLSI, rectangles, overlap detection, sweep line, interval tree, computational geometry"
description: "VLSI databases commonly represent an integrated circuit as a list of rectangles. Give an O(n lg n)-time algorithm to decide whether or not a set of n rectangles so represented contains two rectangles that overlap."
---

> VLSI databases commonly represent an integrated circuit as a list of rectangles. Assume that each rectangle is rectilinearly oriented (sides parallel to the $$x$$- and $$y$$-axes), so that we represent a rectangle by its minimum and maximum $$x$$- and $$y$$-coordinates. Give an $$O(n \lg n)$$-time algorithm to decide whether or not a set of $$n$$ rectangles so represented contains two rectangles that overlap. Your algorithm need not report all intersecting pairs, but it must report that an overlap exists if one rectangle entirely covers another, even if the boundary lines do not intersect. (Hint: Move a "sweep" line across the set of rectangles.)

The hint suggests using a sweep line algorithm. We'll sweep a vertical line from left to right across the plane, maintaining the set of rectangles that currently intersect the sweep line.

{% include ads.html %}

### Key Idea

Two rectangles overlap if and only if their $$x$$-ranges overlap AND their $$y$$-ranges overlap. The sweep line approach:

1. Process rectangles by their $$x$$-coordinates (left and right edges)
2. Maintain an interval tree of $$y$$-ranges for rectangles currently intersecting the sweep line
3. When a rectangle's left edge is reached, check if its $$y$$-range overlaps any existing $$y$$-range in the tree
4. When a rectangle's right edge is reached, remove its $$y$$-range from the tree

### Algorithm

{% capture code %}
Rectangle-Overlap-Exists(R)
    // R[i] = (x_min, x_max, y_min, y_max) for i = 1 to n
    events = []

    // Create events for left and right edges
    for i = 1 to n
        append (R[i].x_min, "left", i) to events
        append (R[i].x_max, "right", i) to events

    // Sort events by x-coordinate
    sort events by x-coordinate

    T = empty interval tree  // stores y-ranges

    for each event (x, type, i) in events
        if type == "left"
            // Check if R[i]'s y-range overlaps any existing y-range
            interval = [R[i].y_min, R[i].y_max]
            if Interval-Search(T, interval) != T.nil
                return true  // Found overlap
            // Insert R[i]'s y-range into tree
            Interval-Insert(T, interval, i)
        else  // type == "right"
            // Remove R[i]'s y-range from tree
            Interval-Delete(T, find_node_by_id(T, i))

    return false  // No overlaps found
{% endcapture %}
{% include clrs_code.html title="Rectangle-Overlap-Exists(R)" %}

### How It Works

The sweep line moves from left to right. At any position $$x$$, the interval tree contains the $$y$$-ranges of all rectangles whose $$x$$-range includes $$x$$ (i.e., rectangles that intersect the vertical line at position $$x$$).

When we encounter the left edge of rectangle $$i$$, we check if its $$y$$-range overlaps any $$y$$-range in the tree. If yes, then rectangle $$i$$ overlaps with some other rectangle $$j$$ that's already in the tree. This is because:
- Rectangle $$i$$'s $$x$$-range starts at the current position
- Rectangle $$j$$'s $$x$$-range includes the current position
- Their $$x$$-ranges overlap
- Their $$y$$-ranges overlap (found by $$\textsc{Interval-Search}$$)
- Therefore, the rectangles overlap

After checking, we insert rectangle $$i$$'s $$y$$-range into the tree. When we encounter the right edge of rectangle $$i$$, we remove its $$y$$-range from the tree.

### Time Complexity

1. Creating events: $$O(n)$$
2. Sorting events: $$O(n \lg n)$$
3. Processing events: $$O(n)$$ events, each involving at most one interval tree operation (search, insert, or delete), each taking $$O(\lg n)$$ time

Total: $$O(n \lg n)$$

### Correctness

**Completeness:** If two rectangles overlap, when we process the left edge of the rectangle with the larger $$x\_min$$, the other rectangle is already in the tree (since its $$x\_min$$ is smaller). The $$\textsc{Interval-Search}$$ will find the overlap.

**Soundness:** If we report an overlap, then two rectangles' $$y$$-ranges overlap and their $$x$$-ranges overlap (one's left edge is within the other's $$x$$-range), so the rectangles overlap.

**Handling Ties:** If two rectangles have the same $$x$$-coordinate for an edge, we process all "right" events before "left" events at that coordinate to avoid false positives.

This algorithm efficiently detects rectangle overlaps using the sweep line technique combined with an interval tree.
