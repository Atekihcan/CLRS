---
title:       Exercise 10.2-7
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "singly linked list, reverse, in-place"
description: "Give a Î˜(n)-time nonrecursive procedure that reverses a singly linked list of n elements. The procedure should use no more than constant storage beyond that needed for the list itself."
---

> Give a $$\Theta(n)$$-time nonrecursive procedure that reverses a singly linked list of $$n$$ elements. The procedure should use no more than constant storage beyond that needed for the list itself.

Reversing a singly linked list means making the last node become the first, the second-to-last become the second, and so on. Since we're limited to constant extra space, we cannot use recursion (which would require $$O(n)$$ stack space) or create a new list. Instead, we must reverse the list in place by redirecting the $$\textit{next}$$ pointers.

The key insight is to traverse the list while reversing pointers as we go. We need to keep track of three nodes at a time: the previous node, the current node, and the next node (to avoid losing our place when we reverse the pointer).

{% capture code %}
REVERSE-LIST(L)
    prev = NIL
    current = L.head
    while current != NIL
        next = current.next     // Save next node
        current.next = prev     // Reverse the pointer
        prev = current          // Move prev forward
        current = next          // Move current forward
    L.head = prev
{% endcapture %}
{% include clrs_code.html %}

Here's how it works step by step:

1. We start with $$\textit{prev} = \textsc{Nil}$$ (which will be the $$\textit{next}$$ pointer of the first node after reversal) and $$\textit{current}$$ pointing to the head.

2. For each node, we:
   - Save the next node (so we don't lose our place)
   - Reverse the current node's pointer to point to the previous node
   - Move both $$\textit{prev}$$ and $$\textit{current}$$ one step forward

3. When $$\textit{current}$$ becomes $$\textsc{Nil}$$, we've processed all nodes, and $$\textit{prev}$$ points to what was the last node (now the new head).

The procedure visits each of the $$n$$ nodes exactly once, performing a constant amount of work per node, giving $$\Theta(n)$$ time. We use only three extra pointers ($$\textit{prev}$$, $$\textit{current}$$, $$\textit{next}$$), which is constant space.

**Example:** Suppose we have a list $$1 \rightarrow 2 \rightarrow 3 \rightarrow \textsc{Nil}$$.
- Initially: $$\textit{prev} = \textsc{Nil}$$, $$\textit{current} = 1$$
- After first iteration: $$\textsc{Nil} \leftarrow 1$$, $$\textit{prev} = 1$$, $$\textit{current} = 2$$
- After second iteration: $$\textsc{Nil} \leftarrow 1 \leftarrow 2$$, $$\textit{prev} = 2$$, $$\textit{current} = 3$$
- After third iteration: $$\textsc{Nil} \leftarrow 1 \leftarrow 2 \leftarrow 3$$, $$\textit{prev} = 3$$, $$\textit{current} = \textsc{Nil}$$
- Final: $$L.\textit{head} = 3$$, giving us $$3 \rightarrow 2 \rightarrow 1 \rightarrow \textsc{Nil}$$
