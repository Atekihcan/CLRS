---
title:       Exercise 11.1-3
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "direct address table, duplicate keys, linked lists"
description: "Suggest how to implement a direct-address table in which the keys of stored elements do not need to be distinct and the elements can have satellite data. All three dictionary operations (INSERT, DELETE, and SEARCH) should run in O(1) time."
---

> Suggest how to implement a direct-address table in which the keys of stored elements do not need to be distinct and the elements can have satellite data. All three dictionary operations ($$\textsc{Insert}$$, $$\textsc{Delete}$$, and $$\textsc{Search}$$) should run in $$O(1)$$ time. (Don't forget that $$\textsc{Delete}$$ takes as an argument a pointer to an object to be deleted, not a key.)

When keys need not be distinct, multiple elements can hash to the same table position. The natural solution is to store a linked list at each position in the direct-address table. Each list contains all elements whose key equals that index.

Let $$T[0 \ldots m-1]$$ be the direct-address table where $$T[k]$$ points to the head of a doubly linked list containing all elements with key $$k$$. Each element $$x$$ in the list stores $$x.key$$ (which equals $$k$$ for all elements in list $$T[k]$$), satellite data, and pointers $$x.next$$ and $$x.prev$$ for the doubly linked list.

{% capture code %}
DirectAddressSearch(T, k)
    return T[k]

DirectAddressInsert(T, x)
    insert x at the head of list T[x.key]

DirectAddressDelete(T, x)
    remove x from the list T[x.key]
{% endcapture %}
{% include clrs_code.html title="Direct-Address Operations with Duplicate Keys" %}

For $$\textsc{Search}(T, k)$$, we simply return the pointer $$T[k]$$, which gives us access to all elements with key $$k$$. This takes $$O(1)$$ time since we just access one array position. If the caller needs to iterate through all elements with that key, they can traverse the returned list.

For $$\textsc{Insert}(T, x)$$, we add element $$x$$ to the front of the list $$T[x.key]$$. Inserting at the head of a doubly linked list takes $$O(1)$$ time: we set $$x.next = T[x.key]$$, set $$x.prev = \textsc{Nil}$$, update the previous head's $$prev$$ pointer if the list is non-empty, and finally set $$T[x.key] = x$$.

For $$\textsc{Delete}(T, x)$$, we remove element $$x$$ from its list. Since $$\textsc{Delete}$$ receives a pointer to the element $$x$$ (not just a key), we can access $$x.key$$, $$x.next$$, and $$x.prev$$ directly. Deleting from a doubly linked list with direct access to the element takes $$O(1)$$ time: we update $$x.prev.next$$ and $$x.next.prev$$ (or update $$T[x.key]$$ if $$x$$ is the head).

This implementation maintains $$O(1)$$ worst-case time for all three operations. The key insight is that $$\textsc{Delete}$$ receives a pointer to the specific element to delete, not just a key value. If $$\textsc{Delete}$$ only received a key and had to find which element to delete, it might need to search through the list, taking more than $$O(1)$$ time.

{% capture note %}
**Why Doubly Linked?**

We use doubly linked lists rather than singly linked lists for deletion efficiency. With a singly linked list, deleting element $$x$$ requires updating $$x$$'s predecessor's $$next$$ pointer. To find the predecessor, we'd need to traverse the list from the head, taking $$O(n)$$ time in the worst case where $$n$$ is the list length. With doubly linked lists, we have direct access to the predecessor through $$x.prev$$, enabling $$O(1)$$ deletion.
{% endcapture %}
{% include aside.html title='Implementation Detail' %}
