---
title:       Problem 12-1
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, equal keys, insertion strategies, performance analysis"
description: "Binary search trees with equal keys. Equal keys pose a problem for the implementation of binary search trees."
---

> **Binary search trees with equal keys**
>
> Equal keys pose a problem for the implementation of binary search trees.
>
> 1. What is the asymptotic performance of $$\textsc{Tree-Insert}$$ when used to insert $$n$$ items with identical keys into an initially empty binary search tree?
>
> We propose to improve $$\textsc{Tree-Insert}$$ by testing before line 5 to determine whether $$z.\textit{key} = x.\textit{key}$$ and by testing before line 11 to determine whether $$z.\textit{key} = y.\textit{key}$$. If equality holds, we implement one of the following strategies. For each strategy, find the asymptotic performance of inserting $$n$$ items with identical keys into an initially empty binary search tree. (The strategies are described for line 5, in which we compare the keys of $$z$$ and $$x$$. Substitute $$y$$ for $$x$$ to arrive at the strategies for line 11.)
>
> 2. Keep a boolean flag $$x.b$$ at node $$x$$, and set $$x$$ to either $$x.\textit{left}$$ or $$x.\textit{right}$$ based on the value of $$x.b$$, which alternates between $$\textsc{False}$$ and $$\textsc{True}$$ each time we visit $$x$$ while inserting a node with the same key as $$x$$.
> 3. Keep a list of nodes with equal keys at $$x$$, and insert $$z$$ into the list.
> 4. Randomly set $$x$$ to either $$x.\textit{left}$$ or $$x.\textit{right}$$. (Give the worst-case performance and informally derive the expected running time.)

### A. Performance of Standard Tree-Insert with Equal Keys

When all $$n$$ keys are identical, $$\textsc{Tree-Insert}$$ always goes right (or always left, depending on whether the implementation uses $$<$$ or $$\le$$ for the comparison).

Each insertion follows the entire right (or left) spine of the tree:
- 1st insertion: creates root
- 2nd insertion: traverses 1 node, adds at depth 1
- 3rd insertion: traverses 2 nodes, adds at depth 2
- $$n$$-th insertion: traverses $$n-1$$ nodes, adds at depth $$n-1$$

Total cost: $$\sum_{i=1}^{n} (i-1) = \sum_{i=0}^{n-1} i = \frac{n(n-1)}{2} = \Theta(n^2)$$

The resulting tree is a linear chain (path) of height $$n-1$$.

### B. Strategy: Alternating Boolean Flag

When $$z.\textit{key} = x.\textit{key}$$, alternate between going left and right using a boolean flag $$x.b$$.

This creates a balanced tree! Each node with equal-key children sends half to the left and half to the right.

Starting from the root:
- Root receives all $$n$$ insertions
- Half go left, half go right (approximately)
- This recursively balances the tree

The resulting tree has height $$\Theta(\lg n)$$:
- Each insertion takes $$O(\lg n)$$ time
- Total: $$O(n \lg n)$$

This is optimal for comparison-based insertion.

**Detailed analysis:**

After inserting $$n$$ items with the same key:
- Root (first item): depth 0
- Next items are distributed roughly evenly via alternation
- Tree structure resembles a complete binary tree

Total insertion cost: $$\sum_{i=1}^{n} O(\lg i) = O(n \lg n)$$

### C. Strategy: List of Equal Keys at Each Node

When $$z.\textit{key} = x.\textit{key}$$, insert $$z$$ into a list stored at $$x$$.

All $$n$$ identical keys end up at the root node:
- 1st insertion: creates root with an empty list
- Subsequent $$n-1$$ insertions: all reach the root, find equal key, insert into list

Cost depends on list implementation:
- If we append to the end of a linked list tracking the tail: $$O(1)$$ per insertion after the first
- If we prepend to the front of a linked list: $$O(1)$$ per insertion after the first
- If we use an array and resize: amortized $$O(1)$$ per insertion

Total cost: $$O(n)$$ âœ“

This is the most efficient strategy for identical keys!

**Trade-off:** While insertion is fast ($$O(n)$$ total), searching, minimum/maximum, and successor/predecessor operations must handle the lists. If we need to distinguish between duplicate keys later (e.g., by insertion order), the list must maintain that information.

{% include ads.html %}

### D. Strategy: Random Left/Right Choice

When $$z.\textit{key} = x.\textit{key}$$, randomly choose to go left or right with equal probability.

**Worst-case performance:**

With bad luck, all random choices could go the same direction (always right or always left), producing a linear chain.

Probability of this: $$2 \cdot (1/2)^{n-1} = 2^{1-(n-1)} = 2^{2-n}$$ (exponentially small)

Worst-case: $$\Theta(n^2)$$ (same as strategy A, but extremely unlikely)

**Expected performance:**

This is equivalent to building a randomly built binary search tree! Each node goes left or right with probability 1/2, independent of other choices.

By Theorem 12.4, the expected height of a randomly built BST is $$O(\lg n)$$.

Expected insertion cost: $$\mathbb{E}\left[\sum_{i=1}^{n} \text{depth of } i\text{-th insertion}\right] = \sum_{i=1}^{n} O(\lg i) = O(n \lg n)$$

This matches Strategy B's performance in expectation, but with the risk of worst-case $$\Theta(n^2)$$ behavior (though exponentially unlikely).

### Summary

| Strategy | Time Complexity | Notes |
|----------|----------------|-------|
| A (Standard) | $$\Theta(n^2)$$ | Linear chain |
| B (Alternating flag) | $$O(n \lg n)$$ | Creates balanced tree |
| C (List at node) | $$O(n)$$ | Optimal for insertion, all keys at root |
| D (Random) | $$O(n \lg n)$$ expected, $$\Theta(n^2)$$ worst-case | Probabilistic balance |

{% capture note %}
**Which strategy to use?**

- **Strategy C (lists)** is best if you expect many duplicate keys and primarily perform insertions. It's the fastest ($$O(n)$$) and simplest.

- **Strategy B (alternating)** is best if you need good performance for all BST operations (search, min/max, successor/predecessor), not just insertion. It maintains logarithmic height deterministically.

- **Strategy D (random)** provides similar expected performance to B with simpler code, but has (tiny) risk of bad behavior.

- **Strategy A (standard)** should be avoided when duplicate keys are common.

In practice, many BST implementations simply don't allow duplicate keys, or they use Strategy C (storing duplicates in a list/count at each node).
{% endcapture %}
{% include aside.html title='Choosing a strategy for duplicate keys' %}
