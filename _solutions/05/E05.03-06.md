---
title:       Exercise 5.3-6
published:   2025-01-13 00:00
modified:    2025-01-13 00:00
keywords:    "randomized algorithms, random permutation, tie breaking"
description: "Explain how to implement the algorithm PERMUTE-BY-SORTING to handle the case in which two or more priorities are identical."
---

> Explain how to implement the algorithm $$\textsc{Permute-By-Sorting}$$ to handle the case in which two or more priorities are identical. That is, your algorithm should produce a uniform random permutation, even if two or more priorities are identical.

When two or more priorities are identical, we need a **tie-breaking** mechanism to ensure the relative order of tied elements is also randomized. Without this, elements with the same priority would maintain their original relative order, introducing bias.

The key insight is to create a **composite key** for sorting that combines the random priority with the original index. When priorities are equal, we break ties using a secondary randomized criterion.

### Method 1: Two-Level Priority

Assign each element two values:

1. **Primary priority**: Random value from $$[1, n^3]$$
2. **Secondary priority**: Random value from $$[1, n^3]$$ (or even $$[1, n^2]$$)

Sort by the primary priority first, then by the secondary priority for ties.

{% capture code %}
n = A.length
let P[1..n] be a new array
let Q[1..n] be a new array
for i = 1 to n
    P[i] = Random(1, n³)
    Q[i] = Random(1, n³)

// Lexicographic sort
sort A using (P[i], Q[i]) as keys
return A
{% endcapture %}
{% include clrs_code.html title="Permute-By-Sorting`(A)" %}

In the sort, elements are compared first by $$P$$[$$i$$]. If $$P$$[$$i$$] = $$P$$[$$j$$], then we compare $$Q$$[$$i$$] and $$Q$$[$$j$$].

The probability of two elements having identical composite keys $$(P[i], Q[i]) = (P[j], Q[j])$$ is $$1/n^6$$, which is negligibly small. The probability that all $$n$$ composite keys are unique is at least $$1 - n(n-1)/(2n^6) > 1 - 1/n^3$$, which approaches 1 very quickly.

### Method 2: Random Tiebreaker Values

A simpler approach assigns each element a unique tiebreaker that's used only when priorities collide:

{% capture code %}
n = A.length
let P[1..n] be a new array
let T[1..n] be a new array
for i = 1 to n
    P[i] = Random(1, n³)
    T[i] = Random(1, n³)

// Custom comparison
if P[i] ≠ P[j]
    sort A using P as keys
else
    sort A using T as keys
return A
{% endcapture %}
{% include clrs_code.html title="Permute-By-Sorting-With-Ties(A)" %}

{% include ads.html %}

### Method 3: Index-Based Tiebreaking with Randomization

We can use the original index as a tiebreaker, but randomize the comparison direction:

{% capture code %}
n = A.length
let P[1..n] be a new array
// 0 for ascending, 1 for descending
tiebreak = Random(0, 1)
for i = 1 to n
    P[i] = Random(1, n³)

// Custom comparison
if P[i] ≠ P[j]
    sort A using P as keys
else if tiebreak == 0
    i < j
else
    i > j

return A
{% endcapture %}
{% include clrs_code.html title="Permute-By-Sorting-Index-Ties(A)" %}

However, this method is less robust because it doesn't fully randomize ties when there are more than two elements with the same priority (for example, if three elements all have the same priority, their relative order is still determined by their original indices).

Without proper tie-breaking, the algorithm would use the sorting algorithm's default behavior for equal elements, which is typically **stable sorting** (maintaining original relative order). This would bias the output permutation.

For example, if $$P = [5, 3, 3, 7]$$ for array $$A = [a, b, c, d]$$, a stable sort would produce $$[b, c, a, d]$$, always keeping $$b$$ before $$c$$. With randomized tie-breaking, $$[c, b, a, d]$$ becomes equally likely, preserving uniformity.

{% capture note %}
The probability of ties occurring is already small with the $$[1, n^3]$$ range (about $$1/n$$ probability of **any** collision), but for correctness, we must handle them. In practice, many implementations use Method 1 or simply generate new priorities when collisions are detected (rejection sampling).
{% endcapture %}
{% include aside.html title='Practical Considerations' %}
