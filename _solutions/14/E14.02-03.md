---
title:       Exercise 14.2-3
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "augmented data structure, associative operator, red-black tree, rotations"
description: "Let ⊗ be an associative binary operator, and let a be an attribute maintained in each node of a red-black tree. Suppose that we want to include in each node x an additional attribute f such that x.f = x₁.a ⊗ x₂.a ⊗ ⋯ ⊗ xₘ.a, where x₁, x₂, ..., xₘ is the inorder listing of nodes in the subtree rooted at x. Show how to update the f attributes in O(1) time after a rotation. Modify your argument slightly to apply it to the size attributes in order-statistic trees."
---

> Let $$\otimes$$ be an associative binary operator, and let $$a$$ be an attribute maintained in each node of a red-black tree. Suppose that we want to include in each node $$x$$ an additional attribute $$f$$ such that $$x.f = x_1.a \otimes x_2.a \otimes \cdots \otimes x_m.a$$, where $$x_1, x_2, \ldots, x_m$$ is the inorder listing of nodes in the subtree rooted at $$x$$. Show how to update the $$f$$ attributes in $$O(1)$$ time after a rotation. Modify your argument slightly to apply it to the size attributes in order-statistic trees.

The key insight is that for an associative operator $$\otimes$$, we can compute $$x.f$$ from the $$f$$ values of its children and its own $$a$$ value, respecting the inorder traversal.

{% include ads.html %}

### Computing f from Local Information

For any node $$x$$, the inorder traversal visits the left subtree, then $$x$$, then the right subtree. Therefore:

$$x.f = x.left.f \otimes x.a \otimes x.right.f$$

This formula depends only on local information ($$x$$, $$x.left$$, and $$x.right$$), so by Theorem 14.1, we can maintain $$f$$ efficiently.

For the sentinel $$T.nil$$, we define $$T.nil.f = e$$ where $$e$$ is the identity element for $$\otimes$$ (i.e., $$e \otimes x = x \otimes e = x$$ for all $$x$$).

### Updating f After a Rotation

Consider a left rotation at node $$x$$ with right child $$y$$. Before rotation:
- $$x.f = x.left.f \otimes x.a \otimes x.right.f$$
- $$y.f = y.left.f \otimes y.a \otimes y.right.f$$
- $$x.right = y$$, so $$x.f = x.left.f \otimes x.a \otimes y.f$$

After rotation, $$y$$ becomes the parent of $$x$$, and $$x.right = y.left$$. The new tree structure has:
- $$x$$'s new subtree consists of: $$x.left$$, $$x$$, $$y.left$$ (in inorder)
- $$y$$'s new subtree consists of: $$x$$'s new subtree, $$y$$, $$y.right$$ (in inorder)

Let's denote the new values with primes. We need:

$$\begin{align*}
x'.f &= x.left.f \otimes x.a \otimes y.left.f \\
y'.f &= x'.f \otimes y.a \otimes y.right.f
\end{align*}$$

We can compute these in $$O(1)$$ time:

```
// After left rotation at x
x.f = x.left.f ⊗ x.a ⊗ y.left.f
y.f = x.f ⊗ y.a ⊗ y.right.f
```

Note that we must update $$x.f$$ first, then use the new value of $$x.f$$ to compute $$y.f$$.

Right rotation is symmetric:

```
// After right rotation at y (with left child x)
y.f = x.right.f ⊗ y.a ⊗ y.right.f
x.f = x.left.f ⊗ x.a ⊗ y.f
```

Each update involves a constant number of $$\otimes$$ operations, so the time is $$O(1)$$ (assuming $$\otimes$$ takes $$O(1)$$ time).

### Application to Size Attributes

For order-statistic trees, we have:
- $$a = 1$$ for all nodes (each node contributes 1 to the count)
- $$\otimes = +$$ (addition)
- $$e = 0$$ (identity for addition)

The formula becomes:

$$x.size = x.left.size + 1 + x.right.size$$

After a left rotation:

$$\begin{align*}
x'.size &= x.left.size + 1 + y.left.size \\
y'.size &= x'.size + 1 + y.right.size
\end{align*}$$

Or equivalently (using the original values):

$$\begin{align*}
x'.size &= x.left.size + 1 + y.left.size \\
y'.size &= (x.left.size + 1 + y.left.size) + 1 + y.right.size \\
        &= x.size - y.size + 1 + y.left.size + 1 + y.right.size \\
        &= x.size
\end{align*}$$

Wait, let me recalculate. Before rotation:
- $$x.size = x.left.size + 1 + y.size$$ (since $$x.right = y$$)
- $$y.size = y.left.size + 1 + y.right.size$$

After rotation:
- $$x'.size = x.left.size + 1 + y.left.size$$
- $$y'.size = x'.size + 1 + y.right.size = (x.left.size + 1 + y.left.size) + 1 + y.right.size$$

But we also have $$y'.size = x.size$$:
$$y'.size = x.left.size + 1 + (y.left.size + 1 + y.right.size) = x.left.size + 1 + y.size = x.size$$

This matches the update code given in Section 14.1:
```
y.size = x.size
x.size = x.left.size + x.right.size + 1
```

where $$x.right$$ is now $$y.left$$ after the rotation. This takes $$O(1)$$ time.
