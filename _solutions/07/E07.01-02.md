---
title:       Exercise 7.1-2
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "quicksort, partition, equal elements, algorithm modification"
description: "What value of q does PARTITION return when all elements in the array A[p..r] have the same value? Modify PARTITION so that q = ⌊(p+r)/2⌋ when all elements in the array A[p..r] have the same value."
---

> What value of $$q$$ does $$\textsc{Partition}$$ return when all elements in the array $$A[p..r]$$ have the same value? Modify $$\textsc{Partition}$$ so that $$q = \lfloor (p+r)/2 \rfloor$$ when all elements in the array $$A[p..r]$$ have the same value.

When all elements have the same value, the $$\textsc{Partition}$$ procedure behaves in a specific way. Since the pivot $$x = A[r]$$ equals all other elements, every comparison $$A[j] \leq x$$ in line 4 evaluates to true. This means the algorithm swaps every element with itself (when $$i$$ catches up to $$j$$), incrementing $$i$$ each time.

Starting with $$i = p - 1$$ and $$j$$ ranging from $$p$$ to $$r - 1$$, after the loop completes, we have $$i = r - 1$$. The final swap in line 7 exchanges $$A[r]$$ with $$A[r - 1 + 1] = A[r]$$, and the procedure returns $$q = r$$.

Therefore, when all elements are equal, $$\textsc{Partition}$$ returns $$q = r$$, creating a highly unbalanced split: one subarray with $$n - 1$$ elements and one empty subarray. This is the worst-case scenario for quicksort.

To achieve $$q = \lfloor (p + r)/2 \rfloor$$ when all elements are equal, we need to detect this case and handle it differently. Here's a modified version:

{% capture code %}
Modified-Partition(A, p, r)
    x = A[r]
    i = p - 1
    equal_count = 0

    for j = p to r - 1
        if A[j] == x
            equal_count = equal_count + 1
        if A[j] ≤ x
            i = i + 1
            exchange A[i] with A[j]

    exchange A[i + 1] with A[r]

    // Check if all elements equal pivot
    if equal_count == r - p
        // All elements in range are equal to pivot
        return ⌊(p + r) / 2⌋
    else
        return i + 1
{% endcapture %}
{% include clrs_code.html title="Modified-Partition(A, p, r)" %}

The key insight is counting how many elements equal the pivot. If $$equal\_count = r - p$$, then all $$r - p$$ elements from $$p$$ to $$r - 1$$ equal the pivot, which means (including the pivot at $$r$$) all elements are identical. In this case, we return the middle index.

{% capture note %}
While this modification achieves the stated goal, it adds overhead to every partition call. A more practical approach (used in real implementations) is the three-way partitioning scheme discussed in Problem 7-2, which naturally handles equal elements efficiently without extra checks.
{% endcapture %}
{% include aside.html title='Practical considerations' %}
