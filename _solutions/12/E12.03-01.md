---
title:       Exercise 12.3-1
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, tree insertion, recursive algorithm"
description: "Give a recursive version of the TREE-INSERT procedure."
---

> Give a recursive version of the $$\textsc{Tree-Insert}$$ procedure.

The iterative version of $$\textsc{Tree-Insert}$$ uses a loop to find the insertion position. We can convert this to a recursive algorithm that searches down the tree and inserts the node when it reaches a $$\textsc{Nil}$$ position.

{% capture code %}
RecursiveTreeInsert(T, z)
    T.root = RecursiveTreeInsertHelper(T.root, z)

RecursiveTreeInsertHelper(x, z)
    if x == NIL
        z.p = NIL
        return z
    if z.key < x.key
        x.left = RecursiveTreeInsertHelper(x.left, z)
        x.left.p = x
    else
        x.right = RecursiveTreeInsertHelper(x.right, z)
        x.right.p = x
    return x
{% endcapture %}
{% include clrs_code.html title='RecursiveTreeInsert(T, z)' %}

The algorithm works as follows:

1. The main procedure $$\textsc{Recursive-Tree-Insert}$$ calls a helper function with the root
2. The helper function recursively searches for the correct insertion position:
   - **Base case:** If $$x = \textsc{Nil}$$, we've found the insertion position, so return $$z$$
   - **Recursive case:** Compare $$z.\textit{key}$$ with $$x.\textit{key}$$ and recurse left or right
3. After recursion returns, set the parent pointer of the inserted node
4. Return $$x$$ so it can be assigned as a child of its parent

### Alternative Version (Passing Parent)

Here is another recursive version that passes the parent node as a parameter, avoiding the need to return and reassign:

{% capture code %}
AlternativeRecursiveTreeInsert(T, z)
    z.left = NIL
    z.right = NIL
    if T.root == NIL
        T.root = z
        z.p = NIL
    else
        TreeInsertRec(T.root, z)

TreeInsertRec(x, z)
    if z.key < x.key
        if x.left == NIL
            x.left = z
            z.p = x
        else
            TreeInsertRec(x.left, z)
    else
        if x.right == NIL
            x.right = z
            z.p = x
        else
            TreeInsertRec(x.right, z)
{% endcapture %}
{% include clrs_code.html title='AlternativeRecursiveTreeInsert(T, z)' %}

{% include ads.html %}

This version more directly mimics the iterative algorithm's logic: when we find a $$\textsc{Nil}$$ child, we attach $$z$$ there and set its parent pointer.

### Time Complexity

Both recursive versions run in $$O(h)$$ time on a tree of height $$h$$, matching the iterative version. The recursion depth is at most $$h$$.

### Example

Inserting key 13 into this tree:

```
        12
       /  \
      5   18
     / \  /  \
    2   9 15  19
```

The recursive calls would be:
1. $$\textsc{Recursive-Tree-Insert-Helper}(12, 13)$$: $$13 > 12$$, go right
2. $$\textsc{Recursive-Tree-Insert-Helper}(18, 13)$$: $$13 < 18$$, go left
3. $$\textsc{Recursive-Tree-Insert-Helper}(15, 13)$$: $$13 < 15$$, go left
4. $$\textsc{Recursive-Tree-Insert-Helper}(\textsc{Nil}, 13)$$: Base case, return 13
5. Unwind recursion, setting parent pointers

Result:

```
        12
       /  \
      5   18
     / \  /  \
    2   9 15  19
           /
         13
```

{% capture note %}
While the recursive version is more elegant and easier to understand conceptually, the iterative version is generally preferred in practice because:
1. It avoids function call overhead
2. It uses $$O(1)$$ space instead of $$O(h)$$ stack space
3. Many compilers do not optimize tail recursion for the second recursive case

However, in functional programming languages, the recursive version is more natural and may be optimized by the compiler.
{% endcapture %}
{% include aside.html title='Recursive vs iterative insertion' %}
