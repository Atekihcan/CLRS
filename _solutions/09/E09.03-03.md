---
title:       Exercise 9.3-3
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "quicksort, worst-case, median, select algorithm, guaranteed performance"
description: "Show how quicksort can be made to run in O(n lg n) time in the worst case, assuming that all elements are distinct."
---

> Show how quicksort can be made to run in $$O(n \lg n)$$ time in the worst case, assuming that all elements are distinct.

The standard quicksort has $$O(n^2)$$ worst-case time because it might consistently choose bad pivots. We can guarantee $$O(n \lg n)$$ worst-case performance by using the $$\textsc{Select}$$ algorithm to choose a good pivot: the median.

{% capture code %}
Worst-Case-Quicksort(A, p, r)
    if p < r
        n = r - p + 1
        i = ⌊(n + 1) / 2⌋
        x = Select(A, p, r, i)
        // Find position of median x and swap to end
        for j = p to r
            if A[j] == x
                swap A[j] with A[r]
                break
        q = Partition(A, p, r)
        Worst-Case-Quicksort(A, p, q - 1)
        Worst-Case-Quicksort(A, q + 1, r)
{% endcapture %}
{% include clrs_code.html %}

By choosing the median as the pivot, we guarantee that each partition divides the array into two subarrays of size at most $$\lfloor n/2 \rfloor$$ and $$\lceil n/2 \rceil - 1$$. This creates the recurrence:

$$\begin{align*}
T(n) &= 2T(n/2) + \Theta(n) + \Theta(n) \\
&= 2T(n/2) + \Theta(n)
\end{align*}$$

The first $$\Theta(n)$$ term is for finding the median using $$\textsc{Select}$$, and the second is for partitioning. By the Master Theorem (case 2), this recurrence has solution $$T(n) = \Theta(n \lg n)$$.

{% capture note %}
While this modified quicksort achieves optimal worst-case performance, it's typically slower in practice than randomized quicksort. The $$\textsc{Select}$$ algorithm has a large constant factor hidden in its $$O(n)$$ running time, making the overhead of finding the median at each level expensive. Randomized quicksort, with its $$O(n \lg n)$$ expected time and small constants, usually performs better on real-world inputs despite its $$O(n^2)$$ worst-case time.
{% endcapture %}
{% include aside.html title='Practical Considerations' %}