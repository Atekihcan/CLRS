---
title:       Exercise 10.4-6
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "rooted tree, pointer optimization, boolean flag, space-efficient representation"
description: "The left-child, right-sibling representation of an arbitrary rooted tree uses three pointers in each node: left-child, right-sibling, and parent. From any node, its parent can be reached and identified in constant time and all its children can be reached and identified in time linear in the number of children. Show how to use only two pointers and one boolean value in each node so that the parent of a node or all of its children can be reached and identified in time linear in the number of children."
---

> The left-child, right-sibling representation of an arbitrary rooted tree uses three pointers in each node: $$\textit{left-child}$$, $$\textit{right-sibling}$$, and $$\textit{parent}$$. From any node, its parent can be reached and identified in constant time and all its children can be reached and identified in time linear in the number of children. Show how to use only two pointers and one boolean value in each node so that the parent of a node or all of its children can be reached and identified in time linear in the number of children.

The key insight is that we can replace the $$\textit{parent}$$ pointer with a pointer that goes "up and left" (to the leftmost sibling, whose $$\textit{left-child}$$ pointer points to us indirectly), or make the sibling chain circular. Let's use a different approach: store only $$\textit{left-child}$$ and $$\textit{left-sibling}$$, with a boolean to indicate whether we're the leftmost child.

Here's a better solution: Keep $$\textit{left-child}$$ and a combined $$\textit{pointer}$$ that can be either $$\textit{right-sibling}$$ or $$\textit{parent}$$, with a boolean $$\textit{is-leftmost}$$ to distinguish.

### Representation

Each node $$x$$ has:
- $$x.\textit{left-child}$$: pointer to the leftmost child
- $$x.\textit{pointer}$$: if $$x$$ is the leftmost child of its parent, this points to the parent; otherwise, it points to the right sibling
- $$x.\textit{is-leftmost}$$: boolean indicating whether $$x$$ is the leftmost child of its parent

### Finding the Parent

{% capture code %}
FIND-PARENT(x)
    if x.is-leftmost
        return x.pointer      // Direct parent pointer
    else
        // Follow siblings left until leftmost
        current = x
        while not current.is-leftmost
            current = current's left sibling
        return current.pointer
{% endcapture %}
{% include clrs_code.html %}

However, this approach requires left-sibling pointers, which adds another pointer. A more efficient representation uses the right-sibling chain.

### Improved Representation

Each node $$x$$ has:
- $$x.\textit{left-child}$$: pointer to the leftmost child
- $$x.\textit{right}$$: pointer to either the right sibling (if $$x$$ has one) or the parent (if $$x$$ is the rightmost child)
- $$x.\textit{has-right-sibling}$$: boolean indicating whether $$x.\textit{right}$$ points to a sibling (true) or parent (false)

### Finding the Parent

{% capture code %}
FIND-PARENT(x)
    current = x
    while current.has-right-sibling
        current = current.right
    return current.right    // This is the parent
{% endcapture %}
{% include clrs_code.html %}

This follows the right-sibling chain until we reach the rightmost sibling, whose $$\textit{right}$$ pointer points to the parent. This takes $$O(k)$$ time where $$k$$ is the number of siblings (which is at most the number of children of the parent).

### Finding All Children

{% capture code %}
FIND-CHILDREN(x)
    if x.left-child == NIL
        return empty list
    child = x.left-child
    children = [child]
    while child.has-right-sibling
        child = child.right
        add child to children
    return children
{% endcapture %}
{% include clrs_code.html %}

This takes $$O(k)$$ time where $$k$$ is the number of children.

### Space Analysis

Each node now uses:
- Two pointers: $$\textit{left-child}$$ and $$\textit{right}$$
- One boolean: $$\textit{has-right-sibling}$$

This is more space-efficient than three pointers, at the cost of making parent access potentially slower ($$O(k)$$ instead of $$O(1)$$, where $$k$$ is the number of siblings).

{% capture note %}
This trade-off is acceptable when space is at a premium and parent access is infrequent compared to child access. The sibling chain naturally leads to the parent, so we're reusing structural information rather than storing redundant pointers.

An alternative representation could use $$\textit{right-child}$$ instead of $$\textit{right-sibling}$$, but the left-child, right-sibling representation is generally preferred because it allows uniform treatment of all children via the sibling chain.
{% endcapture %}
{% include aside.html title='Space-Time Trade-off' %}
