---
title:       Exercise 6.3-2
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "heap, build-max-heap, loop invariant, correctness"
description: "Why do we want the loop index i in line 2 of BUILD-MAX-HEAP to decrease from ⌊A.length/2⌋ to 1 rather than increase from 1 to ⌊A.length/2⌋?"
---

> Why do we want the loop index $$i$$ in line 2 of $$\textsc{Build-Max-Heap}$$ to decrease from $$\lfloor A.length/2 \rfloor$$ to 1 rather than increase from 1 to $$\lfloor A.length/2 \rfloor$$?

The fundamental reason is that $$\textsc{Max-Heapify}$$ has a crucial precondition: it assumes that the binary trees rooted at the left and right children of node $$i$$ are already max-heaps. Think of it like building a pyramid from blocks: you can't place a block on top until the blocks below it are properly positioned.

By iterating downward from $$\lfloor n/2 \rfloor$$ to 1, we process nodes in a bottom-up fashion. This ensures that whenever we call $$\textsc{Max-Heapify}(A, i)$$, both subtrees of node $$i$$ have already been processed and are valid max-heaps, satisfying the precondition.

### What Happens with the Correct Order (Decreasing)

When we start at $$i = \lfloor n/2 \rfloor$$ and move downward:

1. **First nodes processed**: These are nodes just above the leaves. Their children are all leaves, which are trivially max-heaps (single elements always satisfy the heap property).

2. **Higher nodes**: By the time we process node $$i$$, we've already processed all nodes at higher indices (which are descendants of $$i$$). Therefore, both subtrees rooted at $$i$$'s children are guaranteed to be max-heaps.

3. **Loop invariant maintained**: At the start of each iteration, all nodes $$i+1, i+2, \ldots, n$$ are roots of max-heaps.

### What Goes Wrong with Incorrect Order (Increasing)

If we were to iterate upward from 1 to $$\lfloor n/2 \rfloor$$, we would violate $$\textsc{Max-Heapify}$$'s precondition:

1. **Root processed first**: We would call $$\textsc{Max-Heapify}(A, 1)$$ when the subtrees rooted at indices 2 and 3 are not yet max-heaps.

2. **Broken assumption**: $$\textsc{Max-Heapify}$$ might correctly place the root value among itself and its two children, but it cannot fix violations deeper in the tree because those deeper nodes haven't been processed yet.

3. **Invalid result**: After the loop completes, we would have no guarantee that the array represents a valid max-heap.

### Concrete Example

Consider the array $$A = [1, 2, 3]$$:

**Correct order (decreasing from 1 to 1)**:
- $$i = 1$$: Compare 1 with children 2 and 3. Swap 1 with 3.
- Result: $$[3, 2, 1]$$ (valid max-heap)

**Incorrect order (increasing from 1 to 1)**:
- $$i = 1$$: Compare 1 with children 2 and 3. Swap 1 with 3.
- Result: $$[3, 2, 1]$$ (happens to work for this simple case)

But with $$A = [1, 2, 3, 4, 5, 6, 7]$$:

**Incorrect order (increasing from 1 to 3)**:
- $$i = 1$$: Swap 1 with 3, giving $$[3, 2, 1, 4, 5, 6, 7]$$
- $$i = 2$$: Swap 2 with 5, giving $$[3, 5, 1, 4, 2, 6, 7]$$
- $$i = 3$$: Swap 1 with 7, giving $$[3, 5, 7, 4, 2, 6, 1]$$

This violates the max-heap property (3 at root is less than both 5 and 7).

{% capture note %}
The bottom-up approach is not just a matter of preference, it's necessary for correctness. The decreasing loop order ensures that $$\textsc{Max-Heapify}$$'s preconditions are met at every call, allowing it to correctly establish the max-heap property for each subtree.
{% endcapture %}
{% include aside.html title='Correctness Through Dependency Ordering' %}
