---
title:       Exercise 6.2-2
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "heap, min-heapify, min-heap, heap property"
description: "Starting with the procedure MAX-HEAPIFY, write pseudocode for the procedure MIN-HEAPIFY(A, i), which performs the corresponding manipulation on a min-heap. How does the running time of MIN-HEAPIFY compare to that of MAX-HEAPIFY?"
---

> Starting with the procedure $$\textsc{Max-Heapify}$$, write pseudocode for the procedure $$\textsc{Min-Heapify}(A, i)$$, which performs the corresponding manipulation on a min-heap. How does the running time of $$\textsc{Min-Heapify}$$ compare to that of $$\textsc{Max-Heapify}$$?

The key difference between a min-heap and a max-heap is the heap property: in a min-heap, each parent must be smaller than (or equal to) its children, whereas in a max-heap each parent must be larger. So $$\textsc{Min-Heapify}$$ needs to ensure that the smallest value bubbles up to the parent position, rather than the largest.

The logic is symmetric to $$\textsc{Max-Heapify}$$. Instead of finding the largest among the node and its children, we find the smallest. If the current node is not the smallest, we exchange it with the smallest child and recursively fix the violated subtree.

{% capture code %}
MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l ≤ A.heapsize and A[l] < A[i]
        smallest = l
    else smallest = i
    if r ≤ A.heapsize and A[r] < A[smallest]
        smallest = r
    if smallest ≠ i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)
{% endcapture %}
{% include clrs_code.html title="Min-Heapify(A, i)" %}

The changes from $$\textsc{Max-Heapify}$$ are minimal:

1. We renamed `largest` to `smallest`
2. We changed the comparison operators from `>` to `<`
3. Everything else remains the same

The running time of $$\textsc{Min-Heapify}$$ is identical to that of $$\textsc{Max-Heapify}$$. Both procedures perform the same number of operations: constant-time comparisons and exchanges at each level, plus a recursive call that moves down the tree. Since the structure and depth of a min-heap is the same as a max-heap with the same number of elements, the running time is $$O(h)$$ where $$h$$ is the height of the node, or $$O(\lg n)$$ for a heap with $$n$$ elements.

{% capture note %}
The symmetry between $$\textsc{Max-Heapify}$$ and $$\textsc{Min-Heapify}$$ is a beautiful example of duality in data structures. Any algorithm that works on a max-heap can be easily adapted to work on a min-heap by simply reversing the comparison operators. The time complexity remains unchanged because the underlying tree structure is identical.
{% endcapture %}
{% include aside.html title='Duality of Max-Heaps and Min-Heaps' %}
