---
title:       Exercise 12.1-3
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "inorder tree walk, iterative algorithm, stack, Morris traversal"
description: "Give a nonrecursive algorithm that performs an inorder tree walk. (Hint: An easy solution uses a stack as an auxiliary data structure. A more complicated, but elegant, solution uses no stack but assumes that we can test two pointers for equality.)"
---

> Give a nonrecursive algorithm that performs an inorder tree walk. (*Hint:* An easy solution uses a stack as an auxiliary data structure. A more complicated, but elegant, solution uses no stack but assumes that we can test two pointers for equality.)

We present two solutions: one using a stack (straightforward) and one using no additional space (Morris traversal).

### Solution 1: Using a Stack

The stack-based approach explicitly maintains the call stack that recursion would handle implicitly. We push nodes as we traverse left, then pop and visit them, then move right.

{% capture code %}
IterativeInorderTreeWalk(T)
    let S be a new empty stack
    current = T.root
    while current ≠ NIL or S is not empty
        while current ≠ NIL
            S.Push(current)
            current = current.left
        current = S.Pop()
        print current.key
        current = current.right
{% endcapture %}
{% include clrs_code.html title='IterativeInorderTreeWalk(T)' %}

The algorithm works by:
1. Traversing all the way left, pushing nodes onto the stack
2. When we can't go left anymore, pop a node, print it, and move to its right child
3. Repeat until stack is empty and no more nodes to visit

Time complexity: $$\Theta(n)$$ since each node is pushed and popped exactly once.
Space complexity: $$O(h)$$ for the stack, where $$h$$ is the tree height.

### Solution 2: Morris Traversal (No Stack)

This elegant solution uses threading to temporarily modify the tree structure, eliminating the need for a stack. The key idea: when visiting a node, we find its predecessor and make the predecessor's right child point back to the current node, creating a temporary "thread" that lets us return.

{% capture code %}
MorrisInorderTreeWalk(T)
    current = T.root
    while current ≠ NIL
        if current.left == NIL
            print current.key
            current = current.right
        else
            // Find the inorder predecessor
            predecessor = current.left
            while predecessor.right ≠ NIL and predecessor.right ≠ current
                predecessor = predecessor.right

            if predecessor.right == NIL
                // Create thread
                predecessor.right = current
                current = current.left
            else
                // Thread exists, remove it
                predecessor.right = NIL
                print current.key
                current = current.right
{% endcapture %}
{% include clrs_code.html title='MorrisInorderTreeWalk(T)' %}

The algorithm works by:
1. For each node, find its inorder predecessor (rightmost node in left subtree)
2. If the predecessor's right child is $$\textsc{Nil}$$, create a thread back to current node and go left
3. If the thread already exists, we've returned from the left subtree: remove the thread, print current, and go right

Time complexity: $$\Theta(n)$$ because each edge is traversed at most three times (once going down, once for threading, once for cleanup).
Space complexity: $$O(1)$$ as we only use a constant amount of extra space.

{% capture note %}
Morris traversal is particularly useful when memory is constrained. The temporary modifications are always cleaned up before the algorithm finishes, so the tree structure is restored. The pointer equality test mentioned in the hint is used when checking `predecessor.right ≠ current` to detect if a thread already exists.
{% endcapture %}
{% include aside.html title='When to use Morris traversal' %}
