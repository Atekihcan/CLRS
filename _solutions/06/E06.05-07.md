---
title:       Exercise 6.5-7
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "priority queue, FIFO queue, stack, data structure implementation"
description: "Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with a priority queue."
---

> Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with a priority queue. (Queues and stacks are defined in Section 10.1.)

The key to using a priority queue to simulate other data structures is to assign priorities that enforce the desired ordering. For a queue (FIFO), we want the oldest element to have highest priority. For a stack (LIFO), we want the newest element to have highest priority.

Think of it like a ticket dispenser system. For a queue, we give lower ticket numbers (higher priority) to people who arrive earlier. For a stack, we give lower ticket numbers to people who arrive later.

### Implementing a FIFO Queue

A FIFO (first-in, first-out) queue processes elements in the order they arrive. We can simulate this using a max-priority queue by assigning decreasing priorities to elements as they arrive.

Maintain a global counter $$\text{timestamp}$$ initialized to 0. For each $$\textsc{Enqueue}$$ operation:

1. Increment $$\text{timestamp}$$
2. Insert the element with priority $$-\text{timestamp}$$

For $$\textsc{Dequeue}$$, call $$\textsc{Heap-Extract-Max}$$ (or $$\textsc{Heap-Extract-Min}$$ if using a min-priority queue with positive timestamps).

Using a min-priority queue with positive timestamps:

**Enqueue(Q, x):**
```
timestamp = timestamp + 1
Min-Heap-Insert(Q, x, timestamp)
```

**Dequeue(Q):**
```
return Heap-Extract-Min(Q)
```

The element with the smallest timestamp (earliest arrival) has highest priority and is extracted first, giving FIFO behavior.

{% include ads.html %}

### Implementing a Stack

A LIFO (last-in, first-out) stack processes the most recently added element first. We assign increasing priorities to elements as they arrive.

Using the same timestamp approach, for each $$\textsc{Push}$$ operation:

1. Increment $$\text{timestamp}$$
2. Insert the element with priority $$\text{timestamp}$$

For $$\textsc{Pop}$$, call $$\textsc{Heap-Extract-Max}$$.

Using a max-priority queue:

**Push(S, x):**
```
timestamp = timestamp + 1
Max-Heap-Insert(S, x, timestamp)
```

**Pop(S):**
```
return Heap-Extract-Max(S)
```

The element with the largest timestamp (most recent arrival) has highest priority and is extracted first, giving LIFO behavior.

### Analysis

Both implementations support all operations in $$O(\lg n)$$ time, where $$n$$ is the number of elements currently in the structure. This is slower than optimal queue and stack implementations (which achieve $$O(1)$$ for all operations using arrays or linked lists), but it demonstrates the versatility of priority queues.

{% capture note %}
While these implementations work correctly, they're inefficient compared to standard queue and stack implementations. The real lesson here is understanding how priorities can encode different orderings. Priority queues are most valuable when elements truly have varying importance, not just temporal ordering.
{% endcapture %}
{% include aside.html title='Practical Considerations' %}
