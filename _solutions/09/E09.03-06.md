---
title:       Exercise 9.3-6
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "quantiles, order statistics, divide and conquer, selection algorithm"
description: "The kth quantiles of an n-element set are the k − 1 order statistics that divide the sorted set into k equal-sized sets (to within 1). Give an O(n lg k)-time algorithm to list the kth quantiles of a set."
---

> The $$k$$th quantiles of an $$n$$-element set are the $$k - 1$$ order statistics that divide the sorted set into $$k$$ equal-sized sets (to within 1). Give an $$O(n \lg k)$$-time algorithm to list the $$k$$th quantiles of a set.

The $$k$$th quantiles are the elements at positions $$\lfloor n/k \rfloor, \lfloor 2n/k \rfloor, \ldots, \lfloor (k-1)n/k \rfloor$$ in the sorted order. Rather than finding each quantile independently (which would cost $$O(kn)$$), we can use divide and conquer to reuse work across related quantiles.

The key observation is that after finding the median quantile (at position $$\lfloor n/2 \rfloor$$) and partitioning around it, we can recursively find quantiles in the left and right partitions without re-examining elements in the other partition.

{% capture code %}
Find-Quantiles(A, p, r, quantiles)
    if quantiles is empty
        return {}
    if quantiles has only one position j
        return {Select(A, p, r, j - p + 1)}

    // Find median of quantile positions
    m = median position in quantiles
    x = Select(A, p, r, m - p + 1)
    q = Partition-Around(A, p, r, x)

    // Split quantiles into left and right
    left-quantiles = {j ∈ quantiles : j < q}
    right-quantiles = {j ∈ quantiles : j > q}

    // Recursively find quantiles in each partition
    left-results = Find-Quantiles(A, p, q - 1, left-quantiles)
    right-results = Find-Quantiles(A, q + 1, r, right-quantiles)

    return left-results ∪ {x} ∪ right-results
{% endcapture %}
{% include clrs_code.html %}

Initially, we call this with $$quantiles = \{\lfloor n/k \rfloor, \lfloor 2n/k \rfloor, \ldots, \lfloor (k-1)n/k \rfloor\}$$.

{% include ads.html %}

At each level of recursion, we find one order statistic using $$\textsc{Select}$$ in $$O(n)$$ time and partition in $$O(n)$$ time. The recursion tree has depth $$O(\lg k)$$ because we split the $$k-1$$ quantiles roughly in half at each level.

At depth $$d$$, there are at most $$2^d$$ recursive calls, each working on a subarray. Crucially, these subarrays are disjoint (each element belongs to at most one subarray at each level), so the total work at depth $$d$$ is $$O(n)$$.

The total time is:

$$\begin{align*}
T(n, k) &= O(\lg k) \cdot O(n) = O(n \lg k)
\end{align*}$$

This is better than the naive $$O(kn)$$ approach when $$k = o(n/ \lg n)$$, and optimal when $$k = O(\sqrt{n})$$ or smaller.