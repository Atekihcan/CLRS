---
title:       Exercise 6.5-3
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "min-priority queue, min-heap, heap-minimum, heap-extract-min, heap-decrease-key, min-heap-insert"
description: "Write pseudocode for the procedures HEAP-MINIMUM, HEAP-EXTRACT-MIN, HEAP-DECREASE-KEY, and MIN-HEAP-INSERT that implement a min-priority queue with a min-heap."
---

> Write pseudocode for the procedures $$\textsc{Heap-Minimum}$$, $$\textsc{Heap-Extract-Min}$$, $$\textsc{Heap-Decrease-Key}$$, and $$\textsc{Min-Heap-Insert}$$ that implement a min-priority queue with a min-heap.

A min-priority queue is the mirror image of a max-priority queue. Instead of maintaining the largest element at the root, we maintain the smallest. This is useful for applications like event-driven simulation (where we process events in chronological order) or Dijkstra's shortest-path algorithm.

The key insight is that min-priority queue operations are analogous to max-priority queue operations, with all comparisons reversed. Where max-heaps use "greater than" comparisons, min-heaps use "less than" comparisons.

{% include ads.html %}

### Heap-Minimum

{% capture code %}Heap-Minimum(A)
return A[1]
{% endcapture %}
{% include clrs_code.html title="Heap-Minimum" %}

The $$\textsc{Heap-Minimum}$$ procedure simply returns the root element, which is the minimum in a min-heap. This takes $$\Theta(1)$$ time.

### Heap-Extract-Minimum

{% capture code %}Heap-Extract-Min(A)
if Aheapsize < 1
    error "heap underflow"
min = A[1]
A[1] = A[Aheapsize]
Aheapsize = Aheapsize - 1
Min-Heapify(A, 1)
return min
{% endcapture %}
{% include clrs_code.html title="Heap-Extract-Min" %}

The $$\textsc{Heap-Extract-Min}$$ procedure removes and returns the minimum element. It replaces the root with the last element, decreases the heap size, and calls $$\textsc{Min-Heapify}$$ to restore the min-heap property. The running time is $$O(\lg n)$$ due to the $$\textsc{Min-Heapify}$$ call.

### Heap-Decrease-Key

{% capture code %}
if key > A[i]
    error "new key is larger than current key"
A[i] = key
while i > 1 and A[Parent(i)] > A[i]
    exchange A[i] with A[Parent(i)]
    i = Parent(i)
{% endcapture %}
{% include clrs_code.html title="Heap-Decrease-Key(A, i, key)" %}

The $$\textsc{Heap-Decrease-Key}$$ procedure decreases the key of element $$A[i]$$ to the new value. After setting the new key, it bubbles the element up toward the root by repeatedly swapping with its parent whenever the parent is larger (violating the min-heap property). The running time is $$O(\lg n)$$ since the path to the root has length at most the height of the tree.

### Min-Heap-Insert

{% capture code %}
Aheapsize = Aheapsize + 1
A[Aheapsize] = âˆž
Heap-Decrease-Key(A, Aheapsize, key)
{% endcapture %}
{% include clrs_code.html title="Min-Heap-Insert" %}

The $$\textsc{Min-Heap-Insert}$$ procedure adds a new element to the min-heap. It first expands the heap and inserts a sentinel value $$\infty$$ (larger than any actual key) at the new position. Then it calls $$\textsc{Heap-Decrease-Key}$$ to decrease this value to the desired key, which bubbles the new element to its correct position. The running time is $$O(\lg n)$$.
