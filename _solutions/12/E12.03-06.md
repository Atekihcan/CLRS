---
title:       Exercise 12.3-6
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, tree deletion, predecessor, successor, randomization"
description: "When node z in TREE-DELETE has two children, we could choose node y as its predecessor rather than its successor. What other changes to TREE-DELETE would be necessary if we did so? Some have argued that a fair strategy, giving equal priority to predecessor and successor, yields better empirical performance. How might TREE-DELETE be changed to implement such a fair strategy?"
---

> When node $$z$$ in $$\textsc{Tree-Delete}$$ has two children, we could choose node $$y$$ as its predecessor rather than its successor. What other changes to $$\textsc{Tree-Delete}$$ would be necessary if we did so? Some have argued that a fair strategy, giving equal priority to predecessor and successor, yields better empirical performance. How might $$\textsc{Tree-Delete}$$ be changed to implement such a fair strategy?

### Using Predecessor Instead of Successor

The current $$\textsc{Tree-Delete}$$ algorithm uses the successor when $$z$$ has two children. To use the predecessor instead, we need to make symmetric changes:

{% capture code %}
TreeDeleteWithPredecessor(T, z)
    if z.left == NIL
        Transplant(T, z, z.right)
    elseif z.right == NIL
        Transplant(T, z, z.left)
    else
        y = TreeMaximum(z.left)  // Find predecessor (not successor)
        if y.p ≠ z
            Transplant(T, y, y.left)  // Predecessor has no right child
            y.left = z.left           // (symmetric to successor's no left child)
            y.left.p = y
        Transplant(T, z, y)
        y.right = z.right  // Attach z's right subtree to y
        y.right.p = y
{% endcapture %}
{% include clrs_code.html title='TreeDeleteWithPredecessor(T, z)' %}

**Key changes:**

1. **Line 5:** Use $$\textsc{Tree-Maximum}(z.\textit{left})$$ instead of $$\textsc{Tree-Minimum}(z.\textit{right})$$
   - Predecessor is the maximum in left subtree, not minimum in right subtree
2. **Line 7:** Transplant $$y.\textit{left}$$ (not $$y.\textit{right}$$)
   - By Exercise 12.2-5, predecessor has no right child, only possibly a left child
3. **Lines 8-9:** Update $$y.\textit{left}$$ instead of $$y.\textit{right}$$
   - Attach predecessor's left subtree instead of right
4. **Lines 11-12:** Update $$y.\textit{right}$$ (not $$y.\textit{left}$$)
   - Attach $$z$$'s right subtree to the predecessor

The algorithm is completely symmetric to the successor version.

### Fair Strategy: Alternating Predecessor and Successor

To give equal priority to predecessor and successor, we can randomly choose which to use on each deletion:

{% capture code %}
TreeDeleteFair(T, z)
    if z.left == NIL
        Transplant(T, z, z.right)
    elseif z.right == NIL
        Transplant(T, z, z.left)
    else
        // Randomly choose predecessor or successor
        if Random(0, 1) == 0
            // Use predecessor
            y = TreeMaximum(z.left)
            if y.p ≠ z
                Transplant(T, y, y.left)
                y.left = z.left
                y.left.p = y
            Transplant(T, z, y)
            y.right = z.right
            y.right.p = y
        else
            // Use successor
            y = TreeMinimum(z.right)
            if y.p ≠ z
                Transplant(T, y, y.right)
                y.right = z.right
                y.right.p = y
            Transplant(T, z, y)
            y.left = z.left
            y.left.p = y
{% endcapture %}
{% include clrs_code.html title='TreeDeleteFair(T, z)' %}

{% include ads.html %}

### Alternative Fair Strategy: Deterministic Alternation

Instead of randomization, we can deterministically alternate:

{% capture code %}
TreeDeleteAlternating(T, z)
    if z.left == NIL
        Transplant(T, z, z.right)
    elseif z.right == NIL
        Transplant(T, z, z.left)
    else
        // Alternate based on a counter or node property
        if T.delete_counter % 2 == 0
            // Use predecessor on even deletions
            y = TreeMaximum(z.left)
            // ... predecessor logic ...
        else
            // Use successor on odd deletions
            y = TreeMinimum(z.right)
            // ... successor logic ...
        T.delete_counter = T.delete_counter + 1
{% endcapture %}
{% include clrs_code.html title='TreeDeleteAlternating(T, z)' %}

### Why a Fair Strategy Might Improve Performance

Using only successor (or only predecessor) can create imbalance over time:

- If we always use successor, deletions tend to promote nodes from the right subtree
- This can make the tree lean left over many insertions and deletions
- Conversely, always using predecessor makes the tree lean right

A fair strategy:
- Balances the promotions from left and right subtrees
- Helps maintain tree balance over long sequences of mixed insertions and deletions
- Reduces the tendency toward degenerate (skewed) trees

### Empirical Observations

Studies have shown that alternating or randomizing between predecessor and successor:
- Improves average tree height after many operations
- Reduces variance in operation times
- Maintains better balance without the overhead of self-balancing tree structures

However, the improvement is modest compared to using true balanced trees (like red-black trees), which guarantee $$O(\lg n)$$ height.

{% capture note %}
The fair strategy is an example of **randomized algorithms** improving practical performance without changing worst-case complexity. Similar to randomized quicksort, the randomization helps avoid worst-case behavior on pathological inputs.

For production systems where tree height matters, self-balancing trees (Chapter 13) are still preferred. But for simple BST implementations, the fair deletion strategy offers a small improvement at minimal cost.
{% endcapture %}
{% include aside.html title='Practical vs theoretical improvements' %}
