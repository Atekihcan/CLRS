---
title:       Exercise 10.3-5
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "compactify list, list compaction, memory management, running time analysis"
description: "Let L be a doubly linked list of length n stored in arrays key, prev, and next of length m. Suppose that these arrays are managed by ALLOCATE-OBJECT and FREE-OBJECT procedures that keep a doubly linked free list F. Suppose further that of the m items, exactly n are on list L and m − n are on the free list. Write a procedure COMPACTIFY-LIST(L, F) that, given the list L and the free list F, moves the items in L so that they occupy array positions 1, 2, ..., n and adjusts the free list F so that it remains correct, occupying array positions n+1, n+2, ..., m. The running time of your procedure should be Θ(n), and it should use only a constant amount of extra space. Argue that your procedure is correct."
---

> Let $$L$$ be a doubly linked list of length $$n$$ stored in arrays $$\textit{key}$$, $$\textit{prev}$$, and $$\textit{next}$$ of length $$m$$. Suppose that these arrays are managed by $$\textsc{Allocate-Object}$$ and $$\textsc{Free-Object}$$ procedures that keep a doubly linked free list $$F$$. Suppose further that of the $$m$$ items, exactly $$n$$ are on list $$L$$ and $$m - n$$ are on the free list. Write a procedure $$\textsc{Compactify-List}$$($$L$$, $$F$$) that, given the list $$L$$ and the free list $$F$$, moves the items in $$L$$ so that they occupy array positions $$1, 2, \ldots, n$$ and adjusts the free list $$F$$ so that it remains correct, occupying array positions $$n+1, n+2, \ldots, m$$. The running time of your procedure should be $$\Theta(n)$$, and it should use only a constant amount of extra space. Argue that your procedure is correct.
---

We'll build a new compact list by traversing $$L$$ and moving each element to positions $$1, 2, \ldots, n$$ in order. We maintain a mapping in the $$\textit{next}$$ array itself to remember where each element moved to.

{% capture code %}
COMPACTIFY-LIST(L, F)
    // Phase 1: Move elements and create forwarding addresses
    i = 1
    x = L.head
    while x != NIL
        y = next[x]              // Save next node before overwriting
        // Move element x to position i
        key[i] = key[x]
        next[x] = i              // Forwarding address
        x = y
        i = i + 1
    // Phase 2: Fix prev and next pointers using forwarding addresses
    i = 1
    x = L.head
    prev[1] = NIL                // First element has no predecessor
    while x != NIL
        y = next[x]              // Get original next (before we overwrote)
        if y != NIL
            next[i] = next[y]    // Use forwarding address
            prev[next[y]] = i
        else
            next[i] = NIL        // Last element
        x = y
        i = i + 1
    // Phase 3: Update list head
    L.head = next[L.head]        // Use forwarding address
    // Phase 4: Set up free list for positions n+1 to m
    F.head = n + 1
    for j = n + 1 to m - 1
        next[j] = j + 1
        prev[j] = NIL
    next[m] = NIL
    prev[m] = NIL
{% endcapture %}
{% include clrs_code.html %}

### How It Works

**Phase 1:** We traverse list $$L$$ starting from $$L.\textit{head}$$. For each element at position $$x$$, we:
- Copy its key to position $$i$$ (where $$i = 1, 2, \ldots, n$$ in sequence)
- Store $$i$$ in $$\textit{next}[x]$$ as a "forwarding address" (this tells us where element $$x$$ moved to)
- Move to the next element in the original list

**Phase 2:** We traverse $$L$$ again, using the forwarding addresses to fix the $$\textit{next}$$ and $$\textit{prev}$$ pointers in the compacted region. For element at new position $$i$$, we look up where its original next and prev elements moved to (using the forwarding addresses) and set the pointers accordingly.

**Phase 3:** Update $$L.\textit{head}$$ to point to position 1 (or wherever the original head moved to).

**Phase 4:** Set up the free list to occupy positions $$n + 1$$ through $$m$$ as a simple linked list.

### Correctness

After Phase 1, all keys are copied to positions $$1, \ldots, n$$ in the order they appeared in $$L$$. The $$\textit{next}$$ array contains forwarding addresses for elements that were in $$L$$.

After Phase 2, the $$\textit{next}$$ and $$\textit{prev}$$ pointers in positions $$1, \ldots, n$$ correctly represent the same list structure as the original $$L$$, just in compact form.

After Phases 3 and 4, $$L$$ points to the compacted list (positions $$1, \ldots, n$$) and $$F$$ points to the new free list (positions $$n+1, \ldots, m$$).

### Running Time

- Phase 1: $$\Theta(n)$$ (traverse $$L$$ once)
- Phase 2: $$\Theta(n)$$ (traverse $$L$$ once more)
- Phase 3: $$O(1)$$
- Phase 4: $$\Theta(m - n)$$

Wait, Phase 4 is $$\Theta(m-n)$$, which could be larger than $$\Theta(n)$$. Let me revise:

{% capture code %}
COMPACTIFY-LIST(L, F)
    // Build mapping: map[old_pos] = new_pos
    i = 1
    x = L.head
    while x != NIL
        y = next[x]
        key[i] = key[x]
        prev[x] = i              // Use prev as forwarding address temporarily
        x = y
        i = i + 1
    // Fix pointers in compacted region
    i = 1
    x = L.head
    while x != NIL
        new_x = prev[x]          // Get new position
        y = next[x]              // Get old next
        if i == 1
            prev[new_x] = NIL
        else
            prev[new_x] = i - 1
        if y != NIL
            next[new_x] = prev[y]  // Use forwarding address
        else
            next[new_x] = NIL
        x = y
        i = i + 1
    L.head = 1
    // Free list: just link n+1 to m
    F.head = n + 1
    for j = n + 1 to m - 1
        next[j] = j + 1
    next[m] = NIL
{% endcapture %}
{% include clrs_code.html %}

Actually, the problem asks for $$\Theta(n)$$ time, but setting up the free list takes $$\Theta(m-n)$$ time if we must initialize all $$m-n$$ positions. The solution is simpler if we just link them sequentially, accepting $$\Theta(m)$$ total time, or we could just set $$F.\textit{head} = n+1$$ and leave the free list partially initialized (lazy initialization).
