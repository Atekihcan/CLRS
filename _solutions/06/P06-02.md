---
title:       Problem 6-2
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "d-ary heap, heap operations, extract-max, insert, increase-key"
description: "Analysis of d-ary heaps"
---

A $$d$$-ary heap is like a binary heap, but (with one possible exception) non-leaf nodes have $$d$$ children instead of 2 children.

### 1.

The key insight is that we maintain the same level-by-level, left-to-right ordering that binary heaps use. The root is still at position 1, and we fill each level completely before moving to the next level. The difference is that each node now has $$d$$ children instead of 2.

For a node at index $$i$$, we can compute the indices of its parent and children as follows:

$$\begin{align*}
\textsc{Parent}(i) &= \left\lceil \frac{i-1}{d} \right\rceil + 1 = \left\lfloor \frac{i+d-2}{d} \right\rfloor \\
\textsc{Child}_k(i) &= d(i-1) + k + 1 \quad \text{for } k = 1, 2, \ldots, d
\end{align*}$$

More specifically, the children of node $$i$$ are at positions $$d(i-1) + 2, d(i-1) + 3, \ldots, d(i-1) + d + 1$$.

We can verify this works: the root (node 1) has children at positions $$2, 3, \ldots, d+1$$. Node 2 has children at positions $$d+2, d+3, \ldots, 2d+1$$, and so on.

{% capture note %}
For a binary heap ($$d=2$$), these formulas reduce to the familiar $$\textsc{Parent}(i) = \lfloor i/2 \rfloor$$ and $$\textsc{Left}(i) = 2i$$, $$\textsc{Right}(i) = 2i + 1$$.
{% endcapture %}
{% include aside.html title='Generalizing binary heaps' %}

### 2.

Think about how many nodes can fit at each level. A $$d$$-ary heap has 1 node at level 0 (the root), $$d$$ nodes at level 1, $$d^2$$ nodes at level 2, and in general, $$d^h$$ nodes at level $$h$$.

A complete $$d$$-ary heap of height $$h$$ has $$1 + d + d^2 + \cdots + d^h = \frac{d^{h+1} - 1}{d - 1}$$ nodes. For a heap with $$n$$ elements, we have:

$$\begin{align*}
n &\leq \frac{d^{h+1} - 1}{d - 1} < d^{h+1} \\
\lg n &< (h+1) \lg d \\
h &> \frac{\lg n}{\lg d} - 1
\end{align*}$$

Similarly, a heap of height $$h$$ must have at least $$1 + d + d^2 + \cdots + d^{h-1} + 1 = \frac{d^h - 1}{d - 1} + 1$$ nodes (all levels full except the last, which has at least one node):

$$\begin{align*}
n &\geq \frac{d^h - 1}{d - 1} + 1 > d^{h-1} \\
\lg n &> (h-1) \lg d \\
h &< \frac{\lg n}{\lg d} + 1
\end{align*}$$

Therefore, the height of a $$d$$-ary heap with $$n$$ elements is $$\Theta(\log_d n) = \Theta(\frac{\lg n}{\lg d})$$.

{% include ads.html %}

### 3.

The $$\textsc{Extract-Max}$$ operation follows the same pattern as in a binary heap. We replace the root with the last element, decrease the heap size, and then restore the heap property by letting the new root "sink down" to its proper position.

{% capture code %}
D-ARY-EXTRACT-MAX(A)
    if A.heap-size < 1
        error "heap underflow"
    max = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    D-ARY-MAX-HEAPIFY(A, 1)
    return max

D-ARY-MAX-HEAPIFY(A, i)
    largest = i
    for k = 1 to d
        child = d(i - 1) + k + 1
        if child ≤ A.heap-size and A[child] > A[largest]
            largest = child
    if largest ≠ i
        exchange A[i] with A[largest]
        D-ARY-MAX-HEAPIFY(A, largest)
{% endcapture %}
{% include clrs_code.html %}

The key difference from binary heaps is that we must compare the current node with $$d$$ children instead of just 2.

At each level, $$\textsc{D-Ary-Max-Heapify}$$ does $$O(d)$$ work to find the maximum among the node and its $$d$$ children. The procedure may recur down the height of the tree, which is $$O(\log_d n)$$.

Therefore, the total running time is:

$$O(d \cdot \log_d n) = O\left(d \cdot \frac{\lg n}{\lg d}\right) = O\left(\frac{d \lg n}{\lg d}\right)$$

### 4.

The $$\textsc{Insert}$$ operation adds a new element at the end of the heap and then bubbles it up to maintain the heap property, just as in a binary heap.

{% capture code %}
D-ARY-MAX-HEAP-INSERT(A, key)
    A.heap-size = A.heap-size + 1
    A[A.heap-size] = -∞
    D-ARY-HEAP-INCREASE-KEY(A, A.heap-size, key)
{% endcapture %}
{% include clrs_code.html %}

The $$\textsc{Insert}$$ operation calls $$\textsc{D-Ary-Heap-Increase-Key}$$, which we analyze next. Since $$\textsc{Increase-Key}$$ runs in $$O(\log_d n)$$ time (as we'll show), $$\textsc{Insert}$$ also runs in $$O(\log_d n) = O(\frac{\lg n}{\lg d})$$ time.

### 5.

The $$\textsc{Increase-Key}$$ operation updates the key of a node and then bubbles it up the tree, comparing with parents along the way.

{% capture code %}
D-ARY-HEAP-INCREASE-KEY(A, i, key)
    if key < A[i]
        error "new key is smaller than current key"
    A[i] = key
    while i > 1 and A[PARENT(i)] < A[i]
        exchange A[i] with A[PARENT(i)]
        i = PARENT(i)
{% endcapture %}
{% include clrs_code.html %}

Each iteration of the while loop moves up one level in the tree, performing $$O(1)$$ work. The tree has height $$O(\log_d n)$$, so the while loop executes at most $$O(\log_d n)$$ times.

Therefore, the running time is:

$$O(\log_d n) = O\left(\frac{\lg n}{\lg d}\right)$$

{% capture note %}
Notice that for $$\textsc{Extract-Max}$$, increasing $$d$$ makes the operation slower (we must compare with more children), but for $$\textsc{Insert}$$ and $$\textsc{Increase-Key}$$, increasing $$d$$ makes the operations faster (the tree becomes shorter). This tradeoff is important when choosing $$d$$ for a particular application. Priority queues that do more insertions than deletions might benefit from a larger $$d$$.
{% endcapture %}
{% include aside.html title='The tradeoff in choosing d' %}
