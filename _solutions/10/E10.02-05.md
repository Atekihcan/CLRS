---
title:       Exercise 10.2-5
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "singly linked list, circular list, dictionary operations"
description: "Implement the dictionary operations INSERT, DELETE, and SEARCH using singly linked, circular lists. What are the running times of your procedures?"
---

> Implement the dictionary operations $$\textsc{Insert}$$, $$\textsc{Delete}$$, and $$\textsc{Search}$$ using singly linked, circular lists. What are the running times of your procedures?

A circular singly linked list has its last node's $$\textit{next}$$ pointer pointing back to the first node, forming a cycle. Instead of a $$\textit{head}$$ pointer, we typically maintain a pointer to some node in the circle (often called the "access point"). We can detect we've gone full circle when we return to this access point.

For simplicity, let's maintain a pointer $$L.\textit{head}$$ that points to one node in the circular list. An empty list is indicated by $$L.\textit{head} = \textsc{Nil}$$.

{% capture code %}
CIRCULAR-LIST-INSERT(L, x)
    if L.head == NIL
        // Empty list: create single-node cycle
        x.next = x
        L.head = x
    else
        // Insert after L.head
        x.next = L.head.next
        L.head.next = x

CIRCULAR-LIST-SEARCH(L, k)
    if L.head == NIL
        return NIL
    x = L.head
    // Check first node
    if x.key == k
        return x
    // Traverse rest of circle
    x = x.next
    while x != L.head
        if x.key == k
            return x
        x = x.next
    return NIL

CIRCULAR-LIST-DELETE(L, x)
    if L.head == NIL
        error "cannot delete from empty list"
    // Special case: single node
    if L.head.next == L.head
        L.head = NIL
        return
    // Find predecessor of x
    prev = L.head
    while prev.next != x
        prev = prev.next
        if prev == L.head
            error "element not found"
    // Remove x from circle
    prev.next = x.next
    // If x was the head, update head
    if x == L.head
        L.head = prev
{% endcapture %}
{% include clrs_code.html %}

### Running Times

**$$\textsc{Insert}$$:** $$O(1)$$ time. We insert the new node right after $$L.\textit{head}$$ by updating a constant number of pointers.

**$$\textsc{Search}$$:** $$O(n)$$ time in the worst case. We must traverse the entire circular list (potentially visiting all $$n$$ nodes) to find the key or determine it's not present.

**$$\textsc{Delete}$$:** $$O(n)$$ time in the worst case. We must find the predecessor of node $$x$$, which requires traversing the list. In the worst case, we visit all $$n$$ nodes.

The circular structure doesn't provide any asymptotic advantage over a regular singly linked list. The main difference is in handling boundary conditions (no $$\textsc{Nil}$$ pointers at the end) and the need to be careful not to loop forever when traversing.
