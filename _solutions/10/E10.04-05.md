---
title:       Exercise 10.4-5
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "binary tree, Morris traversal, constant space, threading"
description: "Write an O(n)-time nonrecursive procedure that, given an n-node binary tree, prints out the key of each node. Use no more than constant extra space outside of the tree itself and do not modify the tree, even temporarily, during the procedure."
---

> Write an $$O(n)$$-time nonrecursive procedure that, given an $$n$$-node binary tree, prints out the key of each node. Use no more than constant extra space outside of the tree itself and do not modify the tree, even temporarily, during the procedure.

This is a challenging constraint. Without recursion (which uses $$O(h)$$ stack space) or an explicit stack data structure, and without modifying the tree, we need to use the parent pointers to navigate back up the tree. The procedure assumes that each node has a $$\textit{parent}$$ pointer.

{% capture code %}
PRINT-TREE-CONSTANT-SPACE(T)
    if T.root == NIL
        return
    current = T.root
    prev = NIL
    // Continue until we return to root from right subtree
    while current != NIL
        if prev == current.p
            // Coming down from parent
            print current.key
            prev = current
            if current.left != NIL
                current = current.left
            else if current.right != NIL
                current = current.right
            else
                current = current.p
        else if prev == current.left
            // Coming up from left child
            prev = current
            if current.right != NIL
                current = current.right
            else
                current = current.p
        else
            // Coming up from right child (or prev == current.right)
            prev = current
            current = current.p
{% endcapture %}
{% include clrs_code.html %}

{% include ads.html %}

### How It Works

We maintain two pointers: $$\textit{current}$$ (the node we're at) and $$\textit{prev}$$ (the node we came from). By tracking where we came from, we can determine which direction to move next:

1. **Coming down from parent:** We just arrived at this node from above. Print the key, then try to go to the left child. If no left child, try right child. If no children, go back up to parent.

2. **Coming up from left child:** We finished processing the left subtree. Now try to go to the right child. If no right child, go back up to parent.

3. **Coming up from right child:** We finished processing both subtrees. Go back up to parent.

The procedure terminates when we return to the root from its right subtree ($$\textit{current}$$ becomes $$\textsc{Nil}$$ after setting it to the root's parent).

### Running Time

We visit each node a constant number of times (at most 3 times: once going down, potentially once coming from left, and potentially once coming from right). Each visit performs $$O(1)$$ work. Therefore, the total running time is $$O(n)$$.

The space used is $$O(1)$$: just two pointers ($$\textit{current}$$ and $$\textit{prev}$$).

{% capture note %}
This solution assumes parent pointers exist. If parent pointers are not available, there is a more complex algorithm called Morris traversal that temporarily modifies the tree by creating "threads" (temporary links from predecessors to successors), then removes them. However, the problem states we cannot modify the tree, even temporarily.

Without parent pointers and without modification, it's actually impossible to traverse a binary tree in $$O(n)$$ time using $$O(1)$$ space, because we need some way to remember how to get back up the tree.
{% endcapture %}
{% include aside.html title='Parent Pointers Required' %}
