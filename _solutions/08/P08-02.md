---
title:       Problem 8-2
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "in-place sorting, linear time, stability, counting sort, radix sort"
description: "Sorting in place in linear time"
---

> **Sorting in place in linear time**
>
> Suppose that we have an array of $$n$$ data records to sort and that the key of each record has the value 0 or 1. An algorithm for sorting such a set of records might possess some subset of the following three desirable characteristics:
>
> 1. The algorithm runs in $$O(n)$$ time.
> 2. The algorithm is stable.
> 3. The algorithm sorts in place, using no more than a constant amount of storage space in addition to the original array.
>
> 1. Give an algorithm that satisfies criteria 1 and 2 above.
> 2. Give an algorithm that satisfies criteria 1 and 3 above.
> 3. Give an algorithm that satisfies criteria 2 and 3 above.
> 4. Can you use any of your sorting algorithms from parts (a)-(c) as the sorting method used in line 2 of $$\textsc{Radix-Sort}$$, so that $$\textsc{Radix-Sort}$$ sorts $$n$$ records with $$b$$-bit keys in $$O(bn)$$ time? Explain how or why not.
> 5. Suppose that the $$n$$ records have keys in the range from 1 to $$k$$. Show how to modify counting sort so that it sorts the records in place in $$O(n+k)$$ time. You may use $$O(k)$$ storage outside the input array. Is your algorithm stable?

### A. Algorithm satisfying criteria 1 and 2 ($$O(n)$$ time, stable)

Use counting sort:

```python
def stable_binary_sort(A, n):
    # Count 0s and 1s
    count = [0, 0]
    for i in range(n):
        count[A[i]] += 1

    # Build cumulative count
    count[1] = count[0] + count[1]

    # Build output array (not in-place)
    B = [0] * n
    for i in range(n - 1, -1, -1):  # Backward for stability
        B[count[A[i]] - 1] = A[i]
        count[A[i]] -= 1

    return B
```

This is standard counting sort with $$k = 1$$. It's $$O(n)$$ time and stable, but uses $$O(n)$$ extra space.

{% include ads.html %}

### B. Algorithm satisfying criteria 1 and 3 ($$O(n)$$ time, in-place)

Use a partitioning approach (like in quicksort):

```python
def inplace_binary_sort(A, n):
    left = 0    # Position to place next 0
    right = n - 1  # Position to place next 1

    i = 0
    while i <= right:
        if A[i] == 0:
            A[i], A[left] = A[left], A[i]
            left += 1
            i += 1
        else:  # A[i] == 1
            A[i], A[right] = A[right], A[i]
            right -= 1
            # Don't increment i; need to check swapped element

    return A
```

This runs in $$O(n)$$ time and uses $$O(1)$$ extra space, but it's not stable because swaps can reverse the order of equal elements.

### C. Algorithm satisfying criteria 2 and 3 (stable, in-place)

Use insertion sort:

```python
def stable_inplace_binary_sort(A, n):
    for i in range(1, n):
        key = A[i]
        j = i - 1
        while j >= 0 and A[j] > key:
            A[j + 1] = A[j]
            j -= 1
        A[j + 1] = key

    return A
```

Insertion sort is stable and in-place, but takes $$O(n^2)$$ time in the worst case (not $$O(n)$$).

### D. Using in $$\textsc{Radix-Sort}$$

Only algorithm (a) can be used in radix sort because radix sort requires stability.

Algorithms (b) and (c) fail for different reasons:
- Algorithm (b) is in-place and $$O(n)$$, but not stable. Radix sort needs stability to work correctly.
- Algorithm (c) is stable and in-place, but not $$O(n)$$. Using it would make radix sort $$O(bn^2)$$ instead of $$O(bn)$$.

{% include ads.html %}

### E. In-place counting sort for keys 1 to $$k$$

The trick is to use cyclic permutation. Idea: for each position, keep swapping the current element to its correct final position until we find an element that belongs at the current position.

```python
def inplace_counting_sort(A, n, k):
    # Count occurrences: O(n) time, O(k) space
    count = [0] * (k + 1)
    for i in range(n):
        count[A[i]] += 1

    # Compute cumulative positions
    for i in range(1, k + 1):
        count[i] += count[i - 1]

    # Cyclic permutation to place elements
    i = 0
    while i < n:
        # Find correct position for A[i]
        while True:
            correct_pos = count[A[i] - 1]
            count[A[i] - 1] += 1

            if correct_pos == i:
                break  # A[i] is already in correct position

            # Swap A[i] to its correct position
            A[i], A[correct_pos] = A[correct_pos], A[i]

        i += 1

    return A
```

This algorithm:
- Runs in $$O(n + k)$$ time
- Uses $$O(k)$$ space for the count array
- Sorts in place
- **Is NOT stable**: the cyclic swapping disrupts the relative order of equal elements

**Hint for $$k = 3$$:** With values 1, 2, 3, we'd compute positions where each value starts, then cyclically permute elements into their ranges. For example, all 1's go to positions $$[0, c_1)$$, all 2's to $$[c_1, c_2)$$, all 3's to $$[c_2, n)$$.
