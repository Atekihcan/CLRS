---
title:       Exercise 14.2-4
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "red-black tree, range query, enumeration, binary search tree"
description: "We wish to augment red-black trees with an operation RB-ENUMERATE(x, a, b) that outputs all the keys k such that a ≤ k ≤ b in a red-black tree rooted at x. Describe how to implement RB-ENUMERATE in Θ(m + lg n) time, where m is the number of keys that are output and n is the number of internal nodes in the tree."
---

> We wish to augment red-black trees with an operation $$\textsc{RB-Enumerate}(x, a, b)$$ that outputs all the keys $$k$$ such that $$a \leq k \leq b$$ in a red-black tree rooted at $$x$$. Describe how to implement $$\textsc{RB-Enumerate}$$ in $$\Theta(m + \lg n)$$ time, where $$m$$ is the number of keys that are output and $$n$$ is the number of internal nodes in the tree. (Hint: You do not need to add new attributes to the red-black tree.)

The hint tells us we don't need augmentation. We can use a modified inorder traversal that prunes subtrees that can't contain keys in the range $$[a, b]$$.

{% capture code %}
RB-Enumerate(x, a, b)
    if x != T.nil
        // Check if left subtree might contain keys in range
        if a <= x.key
            RB-Enumerate(x.left, a, b)

        // Output current key if it's in range
        if a <= x.key and x.key <= b
            print x.key

        // Check if right subtree might contain keys in range
        if x.key <= b
            RB-Enumerate(x.right, a, b)
{% endcapture %}
{% include clrs_code.html title="RB-Enumerate(x, a, b)" %}

{% include ads.html %}

### How It Works

The algorithm performs an inorder traversal but prunes branches that cannot contain keys in the range $$[a, b]$$.

If the current key $$x.key < a$$, then all keys in the left subtree are also less than $$a$$ (by the BST property), so we don't explore the left subtree. Similarly, if $$x.key > b$$, we don't explore the right subtree.

The three conditions:
1. Recurse left only if $$a \leq x.key$$ (otherwise, all keys in left subtree are too small)
2. Output $$x.key$$ only if $$a \leq x.key \leq b$$
3. Recurse right only if $$x.key \leq b$$ (otherwise, all keys in right subtree are too large)

### Time Complexity Analysis

Let $$m$$ be the number of keys output. The running time is $$\Theta(m + h)$$, where $$h$$ is the number of nodes visited but not output. We need to show that $$h = O(\lg n)$$.

Consider the nodes visited but not output. The nodes visited but not output form at most $$O(\lg n)$$ nodes. Here's why:

Imagine the nodes in range $$[a, b]$$ form a connected subtree (they don't, but bear with me). The algorithm visits:
- The path from root to the minimum key in $$[a, b]$$ (length $$O(\lg n)$$)
- The path from root to the maximum key in $$[a, b]$$ (length $$O(\lg n)$$)
- All nodes in between (these are the $$m$$ output nodes)

The visited-but-not-output nodes are on these two paths. Since the paths share a common prefix from the root to their lowest common ancestor, the total number of distinct nodes on both paths is $$O(\lg n)$$.

More precisely, starting from the root, we follow a path down until we find the first node in the range. This takes $$O(\lg n)$$ time. Then we enumerate all $$m$$ nodes in the range using inorder traversal. Finally, we might visit another $$O(\lg n)$$ nodes after the last node in the range.

Therefore, the total time is $$\Theta(m + \lg n)$$.

### Example

For a tree with keys $$\{1, 3, 5, 7, 9, 11, 13\}$$ and range $$[4, 10]$$:
- We start at root, traverse to find keys in range
- Output: 5, 7, 9
- We visit $$O(\lg n)$$ nodes to find the first key (5) and $$O(\lg n)$$ to finish after the last key (9)
- Total: $$\Theta(3 + \lg 7) = \Theta(m + \lg n)$$
