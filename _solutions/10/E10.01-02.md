---
title:       Exercise 10.1-2
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "stacks, two stacks, array implementation"
description: "Explain how to implement two stacks in one array A[1..n] in such a way that neither stack overflows unless the total number of elements in both stacks together is n. The PUSH and POP operations should run in O(1) time."
---

> Explain how to implement two stacks in one array $$A[1..n]$$ in such a way that neither stack overflows unless the total number of elements in both stacks together is $$n$$. The $$\textsc{Push}$$ and $$\textsc{Pop}$$ operations should run in $$O(1)$$ time.

Think of the array as having two ends. We can grow one stack from the left end (starting at index 1) and the other stack from the right end (starting at index $$n$$). Each stack grows toward the middle of the array. This way, both stacks can use all available space, and overflow only occurs when they meet (meaning the total number of elements equals $$n$$).

Let's maintain two top pointers: $$\textit{top}_1$$ for the first stack and $$\textit{top}_2$$ for the second stack. Initially, $$\textit{top}_1 = 0$$ (stack 1 is empty) and $$\textit{top}_2 = n + 1$$ (stack 2 is empty).

For stack 1, elements are stored at indices $$1, 2, \ldots, \textit{top}_1$$. For stack 2, elements are stored at indices $$n, n-1, \ldots, \textit{top}_2$$. The stacks overflow when $$\textit{top}_1 + 1 = \textit{top}_2$$, meaning there's no space between them.

{% capture code %}
PUSH1(A, x)
    if top₁ + 1 == top₂
        error "overflow"
    top₁ = top₁ + 1
    A[top₁] = x

PUSH2(A, x)
    if top₁ + 1 == top₂
        error "overflow"
    top₂ = top₂ - 1
    A[top₂] = x

POP1(A)
    if top₁ == 0
        error "underflow"
    top₁ = top₁ - 1
    return A[top₁ + 1]

POP2(A)
    if top₂ == n + 1
        error "underflow"
    top₂ = top₂ + 1
    return A[top₂ - 1]
{% endcapture %}
{% include clrs_code.html %}

Each operation performs a constant number of operations (checking conditions, updating pointers, accessing array elements), so the running time is $$O(1)$$ for all operations.

This approach maximizes space utilization because neither stack is limited to a fixed portion of the array. If one stack needs more space while the other is small, it can grow accordingly. Overflow only occurs when the combined size reaches $$n$$, which is optimal.
