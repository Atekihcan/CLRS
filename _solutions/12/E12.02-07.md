---
title:       Exercise 12.2-7
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "inorder tree walk, tree successor, linear time, amortized analysis"
description: "An alternative method of performing an inorder tree walk of an n-node binary search tree finds the minimum element in the tree by calling TREE-MINIMUM and then making n - 1 calls to TREE-SUCCESSOR. Prove that this algorithm runs in Θ(n) time."
---

> An alternative method of performing an inorder tree walk of an $$n$$-node binary search tree finds the minimum element in the tree by calling $$\textsc{Tree-Minimum}$$ and then making $$n - 1$$ calls to $$\textsc{Tree-Successor}$$. Prove that this algorithm runs in $$\Theta(n)$$ time.

At first glance, this seems inefficient: since each call to $$\textsc{Tree-Successor}$$ can take $$O(h)$$ time where $$h$$ is the tree height, we might expect $$n$$ calls to take $$O(nh)$$ time, which could be $$O(n^2)$$ for a skewed tree. However, an amortized analysis shows that the total time is actually $$\Theta(n)$$.

### Algorithm

The algorithm is:

{% capture code %}
AlternativeInorderTreeWalk(T)
    x = TreeMinimum(T.root)
    while x ≠ NIL
        print x.key
        x = TreeSuccessor(x)
{% endcapture %}
{% include clrs_code.html title='AlternativeInorderTreeWalk(T)' %}

### Proof of $$\Theta(n)$$ time

**Key observation:** Each edge in the tree is traversed at most twice during the entire sequence of $$n$$ successor operations (once going up, once going down).

{% include ads.html %}

Consider a tree with $$n$$ nodes. It has exactly $$n - 1$$ edges (since it is a tree). During the entire execution:

1. $$\textsc{Tree-Minimum}$$ walks down from the root to the leftmost node, traversing at most $$h$$ edges: $$O(h)$$ time

2. Each call to $$\textsc{Tree-Successor}$$ either:
   - Goes right once, then follows left children down to the minimum, or
   - Goes up through parent pointers until finding the right ancestor

Let us count edge traversals more carefully. For each node $$x$$ visited during the sequence of successor calls:

- If $$x$$ has a right child, $$\textsc{Tree-Successor}$$ traverses the edge to $$x.\textit{right}$$, then follows left edges down to find the minimum. Each of these edges is traversed exactly once during the entire algorithm.

- If $$x$$ has no right child, $$\textsc{Tree-Successor}$$ walks up through parent pointers. These upward edge traversals are more subtle.

**Amortized analysis using the potential method:**

Each edge $$(u, v)$$ in the tree is traversed in one of two ways:
- **Downward** (from parent to child): at most once per edge
- **Upward** (from child to parent): at most once per edge

During the entire sequence of $$n-1$$ successor calls:

- We traverse each edge downward at most once (when we go right from a node, or when finding the minimum in a right subtree)
- We traverse each edge upward at most once (when moving up to find the right ancestor)

Since there are $$n - 1$$ edges in the tree, the total number of edge traversals across all successor calls is at most $$2(n-1) = O(n)$$.

Adding the initial $$\textsc{Tree-Minimum}$$ call (which takes $$O(h) = O(n)$$), the total time is $$O(n)$$.

Since we must visit all $$n$$ nodes (to print them), the running time is $$\Omega(n)$$.

Therefore, the algorithm runs in $$\Theta(n)$$ time.

### Alternative argument

Another way to see this: during the entire inorder traversal, we:
- Visit each of the $$n$$ nodes exactly once
- Traverse each of the $$n - 1$$ edges at most twice (once in each direction)

Total work: $$O(n + 2(n-1)) = O(n)$$

{% capture note %}
This is an excellent example of amortized analysis. While a single call to $$\textsc{Tree-Successor}$$ might take $$O(h)$$ time in the worst case, when we analyze the total cost of $$n-1$$ successive calls, the amortized cost per call is $$O(1)$$.

The key insight: each edge is "charged" at most twice across all operations. This is similar to the amortized analysis of incrementing a binary counter, where some operations flip many bits, but the amortized cost per increment is $$O(1)$$.
{% endcapture %}
{% include aside.html title='Amortized analysis of successor calls' %}
