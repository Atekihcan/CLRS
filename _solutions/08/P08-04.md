---
title:       Problem 8-4
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "water jugs, comparison problem, lower bound, randomized algorithm, quicksort"
description: "Water jugs"
---

> **Water jugs**
>
> Suppose that you are given $$n$$ red and $$n$$ blue water jugs, all of different shapes and sizes. All red jugs hold different amounts of water, as do the blue ones. Moreover, for every red jug, there is a blue jug that holds the same amount of water, and vice versa.
>
> Your task is to find a grouping of the jugs into pairs of red and blue jugs that hold the same amount of water. To do so, you may perform the following operation: pick a pair of jugs in which one is red and one is blue, fill the red jug with water, and then pour the water into the blue jug. This operation will tell you whether the red or the blue jug can hold more water, or that they have the same volume. Assume that such a comparison takes one time unit. Your goal is to find an algorithm that makes a minimum number of comparisons to determine the grouping. Remember that you may not directly compare two red jugs or two blue jugs.
>
> 1. Describe a deterministic algorithm that uses $$\Theta(n^2)$$ comparisons to group the jugs into pairs.
> 2. Prove a lower bound of $$\Omega(n \lg n)$$ for the number of comparisons that an algorithm solving this problem must make.
> 3. Give a randomized algorithm whose expected number of comparisons is $$O(n \lg n)$$, and prove that this bound is correct. What is the worst-case number of comparisons for your algorithm?

### A. Deterministic $$\Theta(n^2)$$ algorithm

Use a simple nested loop approach:

```python
def match_jugs_quadratic(red_jugs, blue_jugs, n):
    pairs = []

    for i in range(n):
        for j in range(n):
            if compare(red_jugs[i], blue_jugs[j]) == EQUAL:
                pairs.append((red_jugs[i], blue_jugs[j]))
                break  # Found match for red_jugs[i]

    return pairs
```

In the worst case, each red jug is compared with all blue jugs before finding its match. This gives $$\Theta(n^2)$$ comparisons.

{% include ads.html %}

### B. Lower bound of $$\Omega(n \lg n)$$

We use a decision tree argument. The problem requires determining a bijection (one-to-one matching) between red and blue jugs. The number of possible matchings is $$n!$$.

Any comparison-based algorithm must distinguish between all $$n!$$ possible matchings. Using the decision tree model:
- The decision tree must have at least $$n!$$ leaves (one for each possible matching)
- A binary tree of height $$h$$ has at most $$2^h$$ leaves
- Therefore, $$2^h \geq n!$$

Taking logarithms:

$$h \geq \lg(n!) = \Theta(n \lg n)$$

Thus, any algorithm must make $$\Omega(n \lg n)$$ comparisons in the worst case.

### C. Randomized $$O(n \lg n)$$ expected-time algorithm

Use a randomized divide-and-conquer approach similar to quicksort:

```python
def match_jugs_randomized(red_jugs, blue_jugs):
    if len(red_jugs) == 0:
        return []

    # Randomly pick a red jug as pivot
    pivot_red = random.choice(red_jugs)

    # Partition blue jugs using pivot_red
    blue_less = []
    blue_equal = None
    blue_greater = []

    for blue in blue_jugs:
        result = compare(pivot_red, blue)
        if result == LESS:
            blue_greater.append(blue)
        elif result == EQUAL:
            blue_equal = blue
        else:  # GREATER
            blue_less.append(blue)

    # Now partition red jugs using blue_equal
    red_less = []
    red_greater = []

    for red in red_jugs:
        if red == pivot_red:
            continue
        result = compare(red, blue_equal)
        if result == LESS:
            red_less.append(red)
        else:  # GREATER
            red_greater.append(red)

    # Recursively match partitions
    pairs_less = match_jugs_randomized(red_less, blue_less)
    pairs_greater = match_jugs_randomized(red_greater, blue_greater)

    return pairs_less + [(pivot_red, blue_equal)] + pairs_greater
```

**Analysis:**

The algorithm partitions jugs into smaller and greater groups, similar to quicksort:
- Choosing pivot: $$O(1)$$
- Partitioning blue jugs: $$n - 1$$ comparisons
- Partitioning red jugs: $$n - 1$$ comparisons
- Total at this level: $$2n - 2 = O(n)$$

Expected recursion depth: $$O(\lg n)$$ (same analysis as randomized quicksort)

Total expected comparisons: $$O(n \lg n)$$

**Worst case:** If we always pick the smallest/largest jug as pivot, we get unbalanced partitions, leading to $$\Theta(n^2)$$ comparisons (same as quicksort's worst case).

{% capture note %}
This problem is essentially a constrained sorting problem where we can only compare elements from different "colors." The randomized quicksort approach works beautifully because we can use one color as pivots to partition the other color, then use the matched pivot to partition the first color.
{% endcapture %}
{% include aside.html title='Connection to Quicksort' %}
