---
title:       Exercise 8.3-2
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "stable sort, insertion sort, merge sort, heapsort, quicksort"
description: "Which of the following sorting algorithms are stable: insertion sort, merge sort, heapsort, and quicksort? Give a simple scheme that makes any sorting algorithm stable."
---

> Which of the following sorting algorithms are stable: insertion sort, merge sort, heapsort, and quicksort? Give a simple scheme that makes any sorting algorithm stable. How much additional time and space does your scheme entail?

Let's analyze each algorithm's stability:

### Insertion Sort: Stable ✓

When inserting an element into the sorted portion, we stop as soon as we find an element that is less than or equal to (not just less than) the element being inserted. This preserves the relative order of equal elements.

### Merge Sort: Stable ✓

During the merge operation, when elements from both halves are equal, we take from the left subarray first. Since the left subarray contains elements that appeared earlier in the original array, this preserves relative order.

### Heapsort: Not Stable ✗

Heapsort builds a max-heap and repeatedly extracts the maximum. The heap operations can change the relative order of equal elements. For example, with input [2, 2'], heapify operations might place 2' before 2 in the internal representation, causing them to be extracted in reverse order.

### Quicksort: Not Stable ✗

The partitioning step can swap equal elements in ways that reverse their relative order. When the pivot equals some elements, those elements might end up on either side of the pivot position, disrupting their original ordering.

{% include ads.html %}

### Making Any Algorithm Stable

Add a unique index to each element as a secondary key. When comparing elements during sorting:

1. **Preprocessing** ($$\Theta(n)$$ time, $$\Theta(n)$$ space): Create pairs $$(A[i], i)$$ for each element
2. **Comparison rule**: Compare $$(x, i)$$ with $$(y, j)$$ using:
   - If $$x < y$$, then $$(x, i) < (y, j)$$
   - If $$x > y$$, then $$(x, i) > (y, j)$$
   - If $$x = y$$, then $$(x, i) < (y, j)$$ if and only if $$i < j$$
3. **Postprocessing** ($$\Theta(n)$$ time): Extract just the values, discarding indices

This guarantees stability because when values are equal, we break ties using the original position. The cost is $$\Theta(n)$$ additional space for the indices and $$\Theta(n)$$ additional time for pre/postprocessing (asymptotically no change for most algorithms).

{% capture note %}
While this technique works in theory, in practice it's better to use an inherently stable algorithm or carefully implement stability into an existing algorithm rather than adding index pairs everywhere.
{% endcapture %}
{% include aside.html title='Practical Considerations' %}
