---
title:       Exercise 14.1-7
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "order-statistic tree, inversions, counting, sorting, algorithm"
description: "Show how to use an order-statistic tree to count the number of inversions in an array of size n in time O(n lg n)."
---

> Show how to use an order-statistic tree to count the number of inversions (see Problem 2-4) in an array of size $$n$$ in time $$O(n \lg n)$$.

An inversion in an array $$A[1..n]$$ is a pair of indices $$(i, j)$$ such that $$i < j$$ but $$A[i] > A[j]$$. Counting inversions measures how far an array is from being sorted.

The key insight is that for each element $$A[j]$$, we want to count how many elements before position $$j$$ are greater than $$A[j]$$. We can do this efficiently by processing elements from left to right, maintaining an order-statistic tree of all elements seen so far.

{% include ads.html %}

### Algorithm

For each element $$A[j]$$ from left to right:

1. Count how many elements currently in the tree are greater than $$A[j]$$
2. Insert $$A[j]$$ into the tree

To count elements greater than $$A[j]$$, we use the following observation: if $$A[j]$$ were in the tree, its rank would tell us how many elements are less than or equal to it. The number of elements greater than $$A[j]$$ is therefore $$(size - rank)$$, where size is the current size of the tree.

We can compute this by finding where $$A[j]$$ would be inserted and calculating its would-be rank:

{% capture code %}
Count-Inversions(A)
    count = 0
    T = empty order-statistic tree
    for j = 1 to A.length
        r = OS-Key-Rank-Or-Insert-Position(T, A[j])
        count = count + (T.root.size - r + 1)
        Insert(T, A[j])
    return count

OS-Key-Rank-Or-Insert-Position(T, k)
    // Returns rank that k would have if it were in the tree
    x = T.root
    r = 0
    while x != T.nil
        if k <= x.key
            x = x.left
        else
            r = r + x.left.size + 1
            x = x.right
    return r
{% endcapture %}
{% include clrs_code.html title="Count-Inversions(A)" %}

Wait, there's a subtle issue here. When we compute the rank of where $$A[j]$$ would go, we need to be careful about equal elements. Let me reconsider.

Actually, a simpler approach: after inserting $$A[j]$$ into the tree, its rank tells us how many elements in the tree (including $$A[j]$$ itself) are less than or equal to it. Since the tree now contains $$j$$ elements (all elements $$A[1..j]$$), the number of elements before position $$j$$ that are greater than $$A[j]$$ is:

$$(j - \text{rank of } A[j])$$

Here's the corrected algorithm:

{% capture code %}
Count-Inversions(A)
    count = 0
    T = empty order-statistic tree
    for j = 1 to A.length
        Insert(T, A[j])
        r = OS-Rank(T, node just inserted)
        count = count + (j - r)
    return count
{% endcapture %}
{% include clrs_code.html title="Count-Inversions(A)" %}

Each insertion takes $$O(\lg n)$$ time, and each rank computation takes $$O(\lg n)$$ time. Since we perform these operations for each of the $$n$$ elements, the total time complexity is $$O(n \lg n)$$.

For example, with array $$[3, 1, 2]$$:
- Insert 3, rank = 1, inversions so far = $$1 - 1 = 0$$
- Insert 1, rank = 1, inversions so far = $$0 + (2 - 1) = 1$$ (the pair (3,1))
- Insert 2, rank = 2, inversions so far = $$1 + (3 - 2) = 2$$ (the pairs (3,1) and (3,2))

The total is 2 inversions, which is correct.
