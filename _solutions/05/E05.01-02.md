---
title:       Exercise 5.1-2
published:   2025-01-08 10:05
modified:    2025-01-08 10:05
keywords:    "random number generation, binary random, python code"
description: "[Python code] Describe an implementation of the procedure RANDOM(a, b) that only makes calls to RANDOM(0, 1). What is the expected running time of your procedure, as a function of a and b?"
---

> Describe an implementation of the procedure $$\textsc{Random}(a, b)$$ that only makes calls to $$\textsc{Random}(0, 1)$$. What is the expected running time of your procedure, as a function of $$a$$ and $$b$$?

The key insight is to build a random number in the range $$[0, n-1]$$ where $$n = b - a + 1$$, by generating random bits and interpreting them as a binary number.

#### The Algorithm

We use a [**rejection sampling**](https://en.wikipedia.org/wiki/Rejection_sampling){:target="_blank"} approach:

1. Calculate $$n = b - a + 1$$ (the size of the range)
2. Find $$k = \lceil \lg n \rceil$$ (the number of bits needed)
3. Generate $$k$$ random bits to form a number $$r$$ in $$[0, 2^k - 1]$$
4. If $$r < n$$, return $$a + r$$
5. Otherwise, reject this sample and repeat from step 3

{% capture code %}
n = b - a + 1
k = ⌈lg n⌉
while true
    r = 0
    for i = 0 to k - 1
        r = 2 * r + Random(0, 1)
    if r < n
        return a + r
{% endcapture %}
{% include clrs_code.html title="Random(a, b)" %}

{% include ads.html %}

#### Analysis of Expected Running Time

Each iteration generates $$k = \lceil \lg n \rceil$$ bits, which takes $$\Theta(k)$$ time.

The probability of accepting a generated number is:

$$P(\text{accept}) = \frac{n}{2^k}$$

Since $$2^{k-1} < n \le 2^k$$, we have:

$$\frac{n}{2^k} \ge \frac{2^{k-1}}{2^k} = \frac{1}{2}$$

The expected number of iterations is the reciprocal of the acceptance probability:

$$E[\text{iterations}] = \frac{1}{P(\text{accept})} = \frac{2^k}{n} \le 2$$

Therefore, the expected running time is:

$$E[T] = E[\text{iterations}] \cdot k = O(\lg n) = O(\lg(b - a + 1))$$

Since each iteration takes $$\Theta(\lg n)$$ time and we expect at most 2 iterations on average, the total expected running time is $$\Theta(\lg(b - a))$$.

{% capture note %}
This algorithm is quite efficient! Even in the worst case where $$n = 2^{k-1} + 1$$ (just slightly more than a power of 2), we only reject about half the samples on average, requiring an expected 2 iterations.

For example, to generate $$\textsc{Random}(3, 7)$$, we have $$n = 5$$, $$k = 3$$. We generate numbers in $$[0, 7]$$ and accept only $$[0, 4]$$, giving an acceptance rate of $$5/8$$.
{% endcapture %}
{% include aside.html title='Why rejection sampling?' %}

#### Python Implementation

{% include code/code.html file='code/05/code_E050102.py' %}
