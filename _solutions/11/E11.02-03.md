---
title:       Exercise 11.2-3
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "sorted lists, chaining"
description: "Professor Marley hypothesizes that he can obtain substantial performance gains by modifying the chaining scheme to keep each list in sorted order."
---

> Professor Marley hypothesizes that he can obtain substantial performance gains by modifying the chaining scheme to keep each list in sorted order. How does the professor's modification affect the running time for successful searches, unsuccessful searches, insertions, and deletions?

Keeping chains sorted by key provides minimal benefit and actually degrades insertion performance.

**Successful Search:** No asymptotic improvement. We still examine $$\Theta(1 + \alpha)$$ elements on average. We cannot use binary search on a linked list.

**Unsuccessful Search:** Minor improvement in constant factors. We can stop when we encounter a key larger than the target, but the average case remains $$\Theta(1 + \alpha)$$. In practice, we examine about half the chain instead of the full chain.

**Insertion:** Significant degradation from $$O(1)$$ to $$\Theta(1 + \alpha)$$. We must scan the chain to find the correct insertion position to maintain sorted order.

**Deletion:** No change. With a doubly linked list and a pointer to the element, deletion remains $$O(1)$$ regardless of list order.

| Operation | Unsorted | Sorted |
|-----------|----------|--------|
| Successful Search | $$\Theta(1 + \alpha)$$ | $$\Theta(1 + \alpha)$$ |
| Unsuccessful Search | $$\Theta(1 + \alpha)$$ | $$\Theta(1 + \alpha)$$ |
| Insertion | $$O(1)$$ | $$\Theta(1 + \alpha)$$ |
| Deletion | $$O(1)$$ | $$O(1)$$ |

The modification sacrifices fast insertion for marginal search improvements. Hash tables are designed for constant-time operations, so degrading insertion to linear time defeats the purpose. If sorted order is needed, use a balanced binary search tree instead.
