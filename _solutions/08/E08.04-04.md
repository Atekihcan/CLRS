---
title:       Exercise 8.4-4 ⋆
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "bucket sort, unit circle, uniform distribution, geometric probability"
description: "We are given n points in the unit circle. Suppose that the points are uniformly distributed. Design an algorithm with an average-case running time of Θ(n) to sort the n points by their distances from the origin."
---

> We are given $$n$$ points in the unit circle, $$p_i = (x_i, y_i)$$, such that $$0 < x_i^2 + y_i^2 \leq 1$$ for $$i = 1, 2, \ldots, n$$. Suppose that the points are uniformly distributed; that is, the probability of finding a point in any region of the circle is proportional to the area of that region. Design an algorithm with an average-case running time of $$\Theta(n)$$ to sort the $$n$$ points by their distances $$d_i = \sqrt{x_i^2 + y_i^2}$$ from the origin. (Hint: Design the bucket sizes in $$\textsc{Bucket-Sort}$$ to reflect the uniform distribution of the points in the unit circle.)

The key insight is that uniform distribution in the circle means probability is proportional to area. Since area grows as $$r^2$$, we need buckets of non-uniform width to get equal expected counts.

Think about concentric rings in the circle. For a ring from radius $$r_1$$ to $$r_2$$, the area is $$\pi r_2^2 - \pi r_1^2$$. If points are uniformly distributed, the number of points in a ring is proportional to its area.

### Bucket Design

We want $$n$$ buckets with equal expected number of points. Since the total area is $$\pi \cdot 1^2 = \pi$$, each bucket should have area $$\pi/n$$.

Bucket $$i$$ (for $$i = 0, 1, \ldots, n-1$$) should contain points with distances in the range:

$$\sqrt{\frac{i}{n}} \leq d < \sqrt{\frac{i+1}{n}}$$

This ensures each bucket corresponds to an annular region with area:

$$\pi \left(\frac{i+1}{n}\right) - \pi \left(\frac{i}{n}\right) = \frac{\pi}{n}$$

### Algorithm

```python
def sort_points_by_distance(points, n):
    # Create n buckets
    B = [[] for _ in range(n)]

    # Distribute points into buckets
    for (x, y) in points:
        d_squared = x*x + y*y
        # Find bucket index: floor(n * d²)
        bucket_index = min(int(n * d_squared), n - 1)
        B[bucket_index].append((x, y))

    # Sort each bucket (using insertion sort or any O(k²) sort)
    for i in range(n):
        B[i].sort(key=lambda p: p[0]*p[0] + p[1]*p[1])

    # Concatenate buckets
    return [p for bucket in B for p in bucket]
```

### Analysis

With uniform distribution:
- Each bucket has expected size $$\Theta(1)$$
- Distributing points: $$\Theta(n)$$
- Sorting all buckets: $$n \times O(1) = O(n)$$
- Concatenating: $$\Theta(n)$$

Total: $$\Theta(n)$$ average-case time.

{% capture note %}
The trick is using $$d^2$$ rather than $$d$$ for bucket assignment. Since $$d^2 = x^2 + y^2$$ is already computed naturally and $$d^2$$ is uniformly distributed in $$[0, 1]$$ (unlike $$d$$), we can directly use bucket index $$\lfloor n \cdot d^2 \rfloor$$ without taking square roots.
{% endcapture %}
{% include aside.html title='Why Square Distance Works Better' %}
