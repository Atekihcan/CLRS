---
title:       Exercise 10.2-3
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "queue, singly linked list, enqueue, dequeue"
description: "Implement a queue by a singly linked list L. The operations ENQUEUE and DEQUEUE should still take O(1) time."
---

> Implement a queue by a singly linked list $$L$$. The operations $$\textsc{Enqueue}$$ and $$\textsc{Dequeue}$$ should still take $$O(1)$$ time.

A queue requires operations at both ends: we enqueue at the tail and dequeue from the head. The challenge with a singly linked list is that we can only traverse in one direction. To achieve $$O(1)$$ time for both operations, we need to maintain two pointers: one to the head (for dequeue operations) and one to the tail (for enqueue operations).

{% capture code %}
ENQUEUE(Q, x)
    x.next = NIL
    if Q.head == NIL
        // Queue was empty
        Q.head = x
        Q.tail = x
    else
        Q.tail.next = x
        Q.tail = x

DEQUEUE(Q)
    if Q.head == NIL
        error "underflow"
    x = Q.head
    Q.head = Q.head.next
    if Q.head == NIL
        // Queue is now empty
        Q.tail = NIL
    return x
{% endcapture %}
{% include clrs_code.html %}

Both operations run in $$O(1)$$ time:

**$$\textsc{Enqueue}$$** adds a new node to the tail. We set the new node's $$\textit{next}$$ pointer to $$\textsc{Nil}$$, link it from the current tail, and update the tail pointer. If the queue was empty, we also set the head pointer.

**$$\textsc{Dequeue}$$** removes the node at the head. We save the head node, advance the head pointer to the next node, and handle the special case where the queue becomes empty (in which case we must also set the tail pointer to $$\textsc{Nil}$$).

The key insight is that by maintaining both head and tail pointers, we can access both ends of the singly linked list in constant time, even though we can only traverse in one direction.
