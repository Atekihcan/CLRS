---
title:       Exercise 6.5-6
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "heap-increase-key, optimization, insertion sort, assignment reduction"
description: "Each exchange operation on line 5 of HEAP-INCREASE-KEY typically requires three assignments. Show how to use the idea of the inner loop of INSERTION-SORT to reduce the three assignments down to just one assignment."
---

> Each exchange operation on line 5 of $$\textsc{Heap-Increase-Key}$$ typically requires three assignments. Show how to use the idea of the inner loop of $$\textsc{Insertion-Sort}$$ to reduce the three assignments down to just one assignment.

The standard $$\textsc{Heap-Increase-Key}$$ procedure swaps elements at each step, which requires three assignments (using a temporary variable). We can optimize this using the same technique as insertion sort: instead of swapping at each step, we save the key being moved and shift parent values down, making only one assignment per iteration.

Here's the original version with swaps:

{% capture code %}
if key < A[i]
    error "new key is smaller than current key"
A[i] = key
while i > 1 and A[Parent(i)] < A[i]
    exchange A[i] with A[Parent(i)]    // 3 assignments
    i = Parent(i)
{% endcapture %}
{% include clrs_code.html title="Heap-Increase-Key(A, i, key)" %}

The exchange operation on line 5 requires three assignments: `temp = A[i]`, `A[i] = A[Parent(i)]`, and `A[Parent(i)] = temp`.

{% include ads.html %}

Here's the optimized version using insertion sort's technique:

{% capture code %}
if key < A[i]
    error "new key is smaller than current key"
while i > 1 and A[Parent(i)] < key
    A[i] = A[Parent(i)]    // 1 assignment
    i = Parent(i)
A[i] = key
{% endcapture %}
{% include clrs_code.html title="Heap-Increase-Key'(A, i, key)" %}

In this optimized version, we:

1. Compare the new key directly with parent values (not with $$A[i]$$, which changes during the loop).
2. Shift parent values down into the child position (only one assignment per iteration).
3. After the loop terminates, place the key in its final position.

This reduces the number of assignments from $$3h$$ to $$h + 1$$ in the worst case, where $$h$$ is the number of levels the element bubbles up. For a heap with $$n$$ elements, where $$h = O(\lg n)$$, this represents a meaningful constant-factor improvement.
