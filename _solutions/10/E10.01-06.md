---
title:       Exercise 10.1-6
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "queue, stacks, amortized analysis"
description: "Show how to implement a queue using two stacks. Analyze the running time of the queue operations."
---

> Show how to implement a queue using two stacks. Analyze the running time of the queue operations.

A queue is FIFO (first in, first out) while a stack is LIFO (last in, first out). This seems contradictory, but we can use two stacks to reverse the reversal. Think of it like this: if you reverse something twice, you get back the original order.

We'll use two stacks: an "inbox" stack for enqueue operations and an "outbox" stack for dequeue operations. When we enqueue, we simply push onto the inbox. When we dequeue, we pop from the outbox. If the outbox is empty, we transfer all elements from the inbox to the outbox (which reverses their order), then pop from the outbox.

{% capture code %}
ENQUEUE(Q, x)
    PUSH(Q.inbox, x)

DEQUEUE(Q)
    if STACK-EMPTY(Q.outbox)
        if STACK-EMPTY(Q.inbox)
            error "underflow"
        while not STACK-EMPTY(Q.inbox)
            x = POP(Q.inbox)
            PUSH(Q.outbox, x)
    return POP(Q.outbox)
{% endcapture %}
{% include clrs_code.html %}

### Running Time Analysis

$$\textsc{Enqueue}$$ always performs a single $$\textsc{Push}$$ operation, so it takes $$O(1)$$ time in the worst case.

$$\textsc{Dequeue}$$ appears more complex. In the worst case, if the outbox is empty and the inbox has $$n$$ elements, we must transfer all $$n$$ elements from inbox to outbox before we can dequeue. This gives a worst-case time of $$O(n)$$ for a single $$\textsc{Dequeue}$$ operation.

However, the amortized cost per operation is much better. Each element is pushed onto the inbox exactly once, transferred to the outbox at most once, and popped from the outbox exactly once. That's at most 4 operations per element over its lifetime in the queue (1 push to inbox, 1 pop from inbox, 1 push to outbox, 1 pop from outbox).

If we perform a sequence of $$m$$ enqueue and dequeue operations, starting from an empty queue, the total cost is at most $$4m$$ stack operations. Therefore, the amortized cost per operation is $$O(4m/m) = O(1)$$.

{% capture note %}
This two-stack queue implementation is practical and elegant. While a single $$\textsc{Dequeue}$$ can take $$O(n)$$ time in the worst case, the amortized cost of $$O(1)$$ per operation means that the average performance is excellent. This technique of using two stacks to implement a queue is commonly used in functional programming languages.
{% endcapture %}
{% include aside.html title='Practical Considerations' %}
