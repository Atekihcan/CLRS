---
title:       Problem 10-2
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "mergeable heap, linked lists, priority queue, union operation"
description: "A mergeable heap supports the following operations: MAKE-HEAP (which creates an empty mergeable heap), INSERT, MINIMUM, EXTRACT-MIN, and UNION. Show how to implement mergeable heaps using linked lists in each of the following cases. Try to make each operation as efficient as possible. Analyze the running time of each operation in terms of the size of the dynamic set(s) being operated on."
---

> A *mergeable heap* supports the following operations: $$\textsc{Make-Heap}$$ (which creates an empty mergeable heap), $$\textsc{Insert}$$, $$\textsc{Minimum}$$, $$\textsc{Extract-Min}$$, and $$\textsc{Union}$$. Show how to implement mergeable heaps using linked lists in each of the following cases. Try to make each operation as efficient as possible. Analyze the running time of each operation in terms of the size of the dynamic set(s) being operated on.

We'll analyze three different cases: sorted lists, unsorted lists, and unsorted lists with disjoint unions.

### A. Lists are sorted

We maintain a doubly linked list sorted in increasing order (minimum at the head). We also maintain both head and tail pointers.

{% capture code %}
MAKE-HEAP()
    allocate a new list L
    L.head = NIL
    L.tail = NIL
    return L

MINIMUM(H)
    if H.head == NIL
        error "heap underflow"
    return H.head

EXTRACT-MIN(H)
    if H.head == NIL
        error "heap underflow"
    min = H.head
    H.head = H.head.next
    if H.head != NIL
        H.head.prev = NIL
    else
        H.tail = NIL
    return min

INSERT(H, x)
    // Find position to maintain sorted order
    current = H.head
    while current != NIL and current.key < x.key
        current = current.next
    // Insert x before current
    if current == H.head
        x.next = H.head
        x.prev = NIL
        if H.head != NIL
            H.head.prev = x
        else
            H.tail = x
        H.head = x
    else if current == NIL
        x.next = NIL
        x.prev = H.tail
        if H.tail != NIL
            H.tail.next = x
        else
            H.head = x
        H.tail = x
    else
        x.next = current
        x.prev = current.prev
        current.prev.next = x
        current.prev = x

UNION(H₁, H₂)
    // Merge two sorted lists
    result = MAKE-HEAP()
    p1 = H₁.head
    p2 = H₂.head
    while p1 != NIL and p2 != NIL
        if p1.key ≤ p2.key
            INSERT-AT-TAIL(result, p1)
            p1 = p1.next
        else
            INSERT-AT-TAIL(result, p2)
            p2 = p2.next
    while p1 != NIL
        INSERT-AT-TAIL(result, p1)
        p1 = p1.next
    while p2 != NIL
        INSERT-AT-TAIL(result, p2)
        p2 = p2.next
    return result
{% endcapture %}
{% include clrs_code.html %}

**Running times:**
- $$\textsc{Make-Heap}$$: $$O(1)$$
- $$\textsc{Minimum}$$: $$O(1)$$ (head contains minimum)
- $$\textsc{Extract-Min}$$: $$O(1)$$ (remove head)
- $$\textsc{Insert}$$: $$O(n)$$ (must find correct position)
- $$\textsc{Union}$$: $$O(n_1 + n_2)$$ (merge two sorted lists)

{% include ads.html %}

### B. Lists are unsorted

We maintain an unsorted doubly linked list with head and tail pointers.

{% capture code %}
MAKE-HEAP()
    allocate a new list L
    L.head = NIL
    L.tail = NIL
    return L

INSERT(H, x)
    // Insert at head for O(1) time
    x.next = H.head
    x.prev = NIL
    if H.head != NIL
        H.head.prev = x
    else
        H.tail = x
    H.head = x

MINIMUM(H)
    // Search entire list
    if H.head == NIL
        error "heap underflow"
    min = H.head
    current = H.head.next
    while current != NIL
        if current.key < min.key
            min = current
        current = current.next
    return min

EXTRACT-MIN(H)
    min = MINIMUM(H)
    // Remove min from list
    if min.prev != NIL
        min.prev.next = min.next
    else
        H.head = min.next
    if min.next != NIL
        min.next.prev = min.prev
    else
        H.tail = min.prev
    return min

UNION(H₁, H₂)
    // Concatenate lists
    if H₁.head == NIL
        return H₂
    if H₂.head == NIL
        return H₁
    H₁.tail.next = H₂.head
    H₂.head.prev = H₁.tail
    H₁.tail = H₂.tail
    return H₁
{% endcapture %}
{% include clrs_code.html %}

**Running times:**
- $$\textsc{Make-Heap}$$: $$O(1)$$
- $$\textsc{Insert}$$: $$O(1)$$ (insert at head)
- $$\textsc{Minimum}$$: $$O(n)$$ (must search entire list)
- $$\textsc{Extract-Min}$$: $$O(n)$$ (must find minimum first)
- $$\textsc{Union}$$: $$O(1)$$ (just concatenate lists)

### C. Lists are unsorted, and dynamic sets to be merged are disjoint

This is the same as case B. The disjoint property doesn't change the implementation or asymptotic running times, though it may simplify correctness arguments (no need to worry about duplicate elements).

**Running times:** Same as case B.

{% capture note %}
The trade-offs are clear:
- **Sorted lists:** Fast minimum and extract-min operations ($$O(1)$$), but slow insertion ($$O(n)$$) and union ($$O(n_1 + n_2)$$).
- **Unsorted lists:** Fast insertion ($$O(1)$$) and union ($$O(1)$$), but slow minimum and extract-min operations ($$O(n)$$).

If we mostly insert and occasionally extract the minimum, unsorted lists are better. If we frequently need the minimum, sorted lists are better. Neither approach gives us the $$O(\log n)$$ performance of binary heaps for both insertion and extract-min.
{% endcapture %}
{% include aside.html title='Comparison with Binary Heaps' %}
