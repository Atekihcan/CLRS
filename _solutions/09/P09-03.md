---
title:       Problem 9-3
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "order statistics, small indices, tournament, comparisons, selection algorithm"
description: "We showed that the worst-case number T(n) of comparisons used by SELECT to select the ith order statistic from n numbers satisfies T(n) = Θ(n), but the constant hidden by the Θ-notation is rather large. When i is small relative to n, we can implement a different procedure that uses SELECT as a subroutine but makes fewer comparisons in the worst case."
---

> **Small order statistics**
>
> We showed that the worst-case number $$T(n)$$ of comparisons used by $$\textsc{Select}$$ to select the $$i$$th order statistic from $$n$$ numbers satisfies $$T(n) = \Theta(n)$$, but the constant hidden by the $$\Theta$$-notation is rather large. When $$i$$ is small relative to $$n$$, we can implement a different procedure that uses $$\textsc{Select}$$ as a subroutine but makes fewer comparisons in the worst case.
>
> 1. Describe an algorithm that uses $$U_i(n)$$ comparisons to find the $$i$$ smallest of $$n$$ elements, where
>
> $$U_i(n) = \begin{cases} T(n) & \text{if } i \ge n/2 \\ \lfloor n/2 \rfloor + U_i(\lceil n/2 \rceil) + T(2i) & \text{otherwise} \end{cases}$$
>
> (Hint: Begin with $$\lfloor n/2 \rfloor$$ disjoint pairwise comparisons, and recurse on the set containing the smaller element from each pair.)
>
> 2. Show that, if $$i < n/2$$, then $$U_i(n) = n + O(T(2i) \lg(n/i))$$.
> 3. Show that if $$i$$ is a constant less than $$n/2$$, then $$U_i(n) = n + O(\lg n)$$.
> 4. Show that if $$i = n/k$$ for $$k \ge 2$$, then $$U_i(n) = n + O(T(2n/k) \lg k)$$.

### A.

The algorithm exploits the fact that if we want the $$i$$th smallest element and $$i$$ is small, we do not need to examine all $$n$$ elements carefully. We can eliminate roughly half the elements with a simple pairwise comparison phase.

1. If $$i \ge n/2$$, use $$\textsc{Select}$$ directly with $$T(n)$$ comparisons.

2. Otherwise, partition the $$n$$ elements into $$\lfloor n/2 \rfloor$$ pairs (with possibly one element left over). Compare each pair and keep the smaller element from each pair in set $$S$$. This uses $$\lfloor n/2 \rfloor$$ comparisons and produces a set $$S$$ of size $$\lceil n/2 \rceil$$.

3. The $$i$$th smallest overall must be in $$S$$ (since we kept the smaller element from each pair, and at most $$i-1$$ elements in $$S$$ can be smaller than the $$i$$th overall smallest). Recursively find the $$i$$th smallest in $$S$$ using $$U_i(\lceil n/2 \rceil)$$ comparisons.

4. Let $$x$$ be the element found. We know $$x$$ is the $$i$$th smallest in $$S$$, but we need to verify it is the $$i$$th smallest overall. The elements that might be smaller than $$x$$ are: (a) the $$i-1$$ elements in $$S$$ smaller than $$x$$, and (b) the larger elements from pairs where the smaller element was $$\le x$$.

5. Collect the larger elements from pairs whose smaller element is $$\le x$$. There are at most $$2i$$ such elements (at most $$i$$ elements in $$S$$ that are $$\le x$$, each paired with at most one larger element). Use $$\textsc{Select}$$ to find how many of these are actually smaller than $$x$$, using $$T(2i)$$ comparisons.

This gives the recurrence $$U_i(n) = \lfloor n/2 \rfloor + U_i(\lceil n/2 \rceil) + T(2i)$$ for $$i < n/2$$.

### B.

For $$i < n/2$$, we can expand the recurrence:

$$\begin{align*}
U_i(n) &= \lfloor n/2 \rfloor + U_i(\lceil n/2 \rceil) + T(2i) \\
&\le n/2 + U_i(n/2) + T(2i)
\end{align*}$$

Expanding recursively until we reach the base case $$i \ge n/2^k$$:

$$\begin{align*}
U_i(n) &\le \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \cdots + \frac{n}{2^k} + U_i(n/2^k) + kT(2i) \\
&\le n\left(1 - \frac{1}{2^k}\right) + T(n/2^k) + kT(2i)
\end{align*}$$

The recursion bottoms out when $$n/2^k \le 2i$$, so $$k \ge \lg(n/2i) = \lg n - \lg(2i)$$. Taking $$k = \lceil \lg(n/i) \rceil$$:

$$\begin{align*}
U_i(n) &\le n + T(2i) + \lceil \lg(n/i) \rceil \cdot T(2i) \\
&= n + O(T(2i) \lg(n/i))
\end{align*}$$

{% include ads.html %}

### C.

If $$i$$ is a constant, then $$T(2i) = O(1)$$ since $$\textsc{Select}$$ runs in linear time with a constant input size. From part B:

$$\begin{align*}
U_i(n) &= n + O(T(2i) \lg(n/i)) \\
&= n + O(\lg(n/i)) \\
&= n + O(\lg n)
\end{align*}$$

This is significantly better than the $$T(n) = \Theta(n)$$ bound for general $$\textsc{Select}$$, which has a large constant factor.

### D.

If $$i = n/k$$ for $$k \ge 2$$, then from part B:

$$\begin{align*}
U_i(n) &= n + O(T(2i) \lg(n/i)) \\
&= n + O(T(2n/k) \lg(n/(n/k))) \\
&= n + O(T(2n/k) \lg k)
\end{align*}$$

For example, finding the quartiles ($$k = 4$$) takes $$n + O(T(n/2) \lg 4) = n + O(n)$$ time, but with a smaller constant than standard $$\textsc{Select}$$ because $$\lg 4 = 2$$ is small.
