---
title:       Exercise 10.1-5
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "deque, double-ended queue, array implementation"
description: "Whereas a stack allows insertion and deletion of elements at only one end, and a queue allows insertion at one end and deletion at the other end, a deque (double-ended queue) allows insertion and deletion at both ends. Write four O(1)-time procedures to insert elements into and delete elements from both ends of a deque implemented by an array."
---

> Whereas a stack allows insertion and deletion of elements at only one end, and a queue allows insertion at one end and deletion at the other end, a *deque* (double-ended queue) allows insertion and deletion at both ends. Write four $$O(1)$$-time procedures to insert elements into and delete elements from both ends of a deque implemented by an array.

A deque is like a queue that's flexible at both ends. Think of it as a line where people can join or leave from either the front or the back. We can implement this using a circular array similar to the queue implementation, but now we need to handle operations at both ends.

We'll maintain two pointers: $$\textit{head}$$ pointing to the front element and $$\textit{tail}$$ pointing to the next available position after the last element. The array wraps around circularly, just like with a regular queue.

For insertion at the tail (right end), we behave like a regular queue's enqueue. For insertion at the head (left end), we need to decrement the head pointer (with wraparound). Similarly, deletion from the head is like dequeue, and deletion from the tail requires decrementing the tail pointer.

{% capture code %}
INSERT-HEAD(D, x)
    if D.head == 1
        D.head = D.length
    else
        D.head = D.head - 1
    D[D.head] = x
    if D.head == D.tail
        error "overflow"

INSERT-TAIL(D, x)
    D[D.tail] = x
    if D.tail == D.length
        D.tail = 1
    else
        D.tail = D.tail + 1
    if D.head == D.tail
        error "overflow"

DELETE-HEAD(D)
    if D.head == D.tail
        error "underflow"
    x = D[D.head]
    if D.head == D.length
        D.head = 1
    else
        D.head = D.head + 1
    return x

DELETE-TAIL(D)
    if D.head == D.tail
        error "underflow"
    if D.tail == 1
        D.tail = D.length
    else
        D.tail = D.tail - 1
    return D[D.tail]
{% endcapture %}
{% include clrs_code.html %}

Each procedure performs a constant number of operations: checking conditions, updating a pointer (with possible wraparound), and accessing an array element. Therefore, all four operations run in $$O(1)$$ time.

{% capture note %}
Like the queue implementation, this deque can store at most $$n - 1$$ elements in an array of length $$n$$ because we use $$\textit{head} = \textit{tail}$$ to indicate an empty deque. The overflow condition ($$\textit{head} = \textit{tail}$$ after insertion) means the deque is full.
{% endcapture %}
{% include aside.html title='Space Limitation' %}
