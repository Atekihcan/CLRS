---
title:       Exercise 12.2-3
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, tree predecessor, symmetric operation"
description: "Write the TREE-PREDECESSOR procedure."
---

> Write the $$\textsc{Tree-Predecessor}$$ procedure.

The $$\textsc{Tree-Predecessor}$$ procedure is symmetric to $$\textsc{Tree-Successor}$$. Given a node $$x$$, it returns the node with the largest key smaller than $$x.\textit{key}$$.

{% capture code %}
TreePredecessor(x)
    if x.left ≠ NIL
        return TreeMaximum(x.left)
    y = x.p
    while y ≠ NIL and x == y.left
        x = y
        y = y.p
    return y
{% endcapture %}
{% include clrs_code.html title='TreePredecessor(x)' %}

The algorithm has two cases:

**Case 1: Node** $$x$$ **has a left subtree** (line 1-2).

If $$x$$ has a left subtree, its predecessor is the maximum element in that left subtree. This is the rightmost node in the left subtree, which we find by calling $$\textsc{Tree-Maximum}(x.\textit{left})$$.

For example, in this tree:

```
      15
     /  \
    6   18
   / \  / \
  3   7 17 20
 / \   \
2   4  13
       /
      9
```

The predecessor of node 15 is node 13 (the maximum in 15's left subtree).

**Case 2: Node** $$x$$ **has no left subtree** (lines 3-7).

If $$x$$ has no left subtree and has a predecessor $$y$$, then $$y$$ is the lowest ancestor of $$x$$ whose right child is also an ancestor of $$x$$. We find this by walking up the tree from $$x$$ until we encounter a node that is the right child of its parent.

For example, the predecessor of node 17 is node 15 (we go up from 17 to 18, which is the right child of 15).

If we walk all the way up to the root without finding such a node, then $$x$$ is the minimum element in the tree and has no predecessor, so we return $$\textsc{Nil}$$.

### Correctness

The algorithm is correct because:

{% include ads.html %}

1. If $$x$$ has a left subtree, all keys in that subtree are smaller than $$x.\textit{key}$$, and the maximum among them is the largest key smaller than $$x.\textit{key}$$
2. If $$x$$ has no left subtree, the predecessor must be an ancestor. Specifically, it is the first ancestor for which $$x$$ is in the right subtree (since all keys in a right subtree are larger than the ancestor)

### Time Complexity

The procedure runs in $$O(h)$$ time on a tree of height $$h$$, matching $$\textsc{Tree-Successor}$$.

{% capture note %}
The symmetry between $$\textsc{Tree-Successor}$$ and $$\textsc{Tree-Predecessor}$$ is complete:
- Successor uses left child and right subtree; Predecessor uses right child and left subtree
- Successor walks up while node is a right child; Predecessor walks up while node is a left child
- Successor finds minimum in right subtree; Predecessor finds maximum in left subtree

This symmetry reflects the dual nature of the BST property: smaller keys to the left, larger keys to the right.
{% endcapture %}
{% include aside.html title='Symmetry in BST operations' %}
