---
title:       Exercise 14.3-4
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "interval tree, enumerate overlaps, query complexity, output-sensitive"
description: "Given an interval tree T and an interval i, describe how to list all intervals in T that overlap i in O(min(n, k lg n)) time, where k is the number of intervals in the output list."
---

> Given an interval tree $$T$$ and an interval $$i$$, describe how to list all intervals in $$T$$ that overlap $$i$$ in $$O(\min(n, k \lg n))$$ time, where $$k$$ is the number of intervals in the output list. (Hint: One simple method makes several queries, modifying the tree between queries. A slightly more complicated method does not modify the tree.)

The hint suggests two approaches. Let's explore both.

### Method 1: Modify the Tree (Simple)

Repeatedly call $$\textsc{Interval-Search}$$ to find an overlapping interval, output it, delete it from the tree, and repeat until no more overlapping intervals exist.

{% capture code %}
Interval-Search-All-Modify(T, i)
    while true
        x = Interval-Search(T, i)
        if x == T.nil
            break
        print x.int
        Interval-Delete(T, x)
{% endcapture %}
{% include clrs_code.html title="Interval-Search-All-Modify(T, i)" %}

Each call to $$\textsc{Interval-Search}$$ takes $$O(\lg n)$$ time, and each deletion takes $$O(\lg n)$$ time. With $$k$$ overlapping intervals, the total time is $$O(k \lg n)$$.

However, this modifies the tree, which may not be desirable. After the query, we'd need to reinsert all deleted intervals, taking another $$O(k \lg n)$$ time.

{% include ads.html %}

### Method 2: Don't Modify the Tree

Use a modified inorder traversal that prunes subtrees that cannot contain overlapping intervals, similar to $$\textsc{RB-Enumerate}$$ from Exercise 14.2-4.

{% capture code %}
Interval-Search-All(T, i)
    Interval-Search-All-Helper(T.root, i)

Interval-Search-All-Helper(x, i)
    if x == T.nil
        return

    // Check left subtree if it might contain overlapping intervals
    if x.left != T.nil and x.left.max >= i.low
        Interval-Search-All-Helper(x.left, i)

    // Check if current interval overlaps
    if i overlaps x.int
        print x.int

    // Check right subtree if it might contain overlapping intervals
    if x.int.low <= i.high
        Interval-Search-All-Helper(x.right, i)
{% endcapture %}
{% include clrs_code.html title="Interval-Search-All(T, i)" %}

### Pruning Logic

1. **Left subtree:** Explore left only if $$x.left.max \geq i.low$$. If $$x.left.max < i.low$$, then all intervals in the left subtree have $$high < i.low$$, so none can overlap $$i$$.

2. **Right subtree:** Explore right only if $$x.int.low \leq i.high$$. Since all intervals in the right subtree have $$low \geq x.int.low$$, if $$x.int.low > i.high$$, then all intervals in the right subtree have $$low > i.high$$, so none can overlap $$i$$.

### Time Complexity

Let $$k$$ be the number of overlapping intervals found. The analysis from Exercise 14.2-4 applies here: the algorithm visits $$k$$ nodes that it outputs, plus $$O(\lg n)$$ nodes that it visits but doesn't output (nodes on paths from root to the first/last overlapping interval).

Therefore, the time complexity is $$O(k + \lg n)$$. This is $$O(\min(n, k \lg n))$$ since $$k \leq n$$ and $$\lg n \leq k \lg n$$ when $$k \geq 1$$. In the worst case where we might visit all $$n$$ nodes (when intervals are spread across the tree), the time is $$O(n)$$, giving us the $$O(\min(n, k \lg n))$$ bound.

Both methods achieve the desired complexity, but Method 2 doesn't modify the tree.
