---
title:       Problem 8-3
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "variable-length items, radix sort, string sorting, integer sorting"
description: "Sorting variable-length items"
---

> **Sorting variable-length items**
>
> 1. You are given an array of integers, where different integers may have different numbers of digits, but the total number of digits over all the integers in the array is $$n$$. Show how to sort the array in $$O(n)$$ time.
> 2. You are given an array of strings, where different strings may have different numbers of characters, but the total number of characters over all the strings is $$n$$. Show how to sort the strings in $$O(n)$$ time.
>
> (Note that the desired order here is the standard alphabetical order; for example, a < ab < b.)

### A. Sorting variable-length integers

The key insight is that we can still use radix sort if we group integers by their length first, then sort within each group.

**Algorithm:**

1. **Group by length** ($$O(n)$$ time):
   - Scan all integers and group them by number of digits
   - Since total digits = $$n$$, this scan takes $$O(n)$$ time

2. **Sort each group using radix sort** ($$O(n)$$ total time):
   - For integers with $$d$$ digits, use radix sort with $$d$$ passes
   - Each pass over integers with $$d$$ digits takes $$O(d)$$ time per integer using counting sort (base 10)
   - Sum over all groups: if group $$i$$ has $$n_i$$ integers of length $$d_i$$, total time is $$\sum n_i \cdot d_i$$
   - But $$\sum n_i \cdot d_i = n$$ (total number of digits), so this is $$O(n)$$

3. **Concatenate groups** ($$O(n)$$ time):
   - Shorter integers come before longer ones
   - Within each length, use the radix sort result

**Why this works:** An integer with fewer digits is always smaller than one with more digits (assuming positive integers). So we can sort by length first, then within each length group.

Total time: $$O(n)$$.

{% include ads.html %}

### B. Sorting variable-length strings

This is trickier because string comparison is lexicographic, not length-based. The string "b" comes after "ab" even though it's shorter.

**Algorithm:**

1. **Find maximum length** $$\ell_{max}$$ ($$O(n)$$ time)

2. **Pad all strings conceptually with a special character** that is lexicographically smaller than all alphabetic characters. This makes all strings the same length $$\ell_{max}$$.

3. **Use radix sort from right to left** ($$O(n)$$ total time):
   - For each position $$i$$ from $$\ell_{max}$$ down to 1:
     - Sort strings by character at position $$i$$ using counting sort
     - Treat the padding character as smaller than all letters
     - Time per pass: $$O(\text{number of strings} + 26)$$
   - Total across all passes: We process each character position once
   - Each character in the original input contributes to exactly one position, so total is $$O(n + k \cdot \ell_{max})$$ where $$k$$ is the number of strings
   - Since $$k \cdot \ell_{max} \leq n$$ (total characters), this is $$O(n)$$

**Example:** To sort ["b", "ab", "a"]:
- Pad to length 2: ["b ", "ab", "a "] (using space as padding)
- Pass 1 (position 2): [" a", "ab", " b"] (sorted by last char)
- Pass 2 (position 1): ["a ", "ab", "b "] (sorted by first char)
- Result: ["a", "ab", "b"]

**Optimization:** We don't actually need to pad; instead, when comparing at position $$i$$, treat strings shorter than $$i$$ as having the special padding character at that position.

Total time: $$O(n)$$.

{% capture note %}
For strings, we're essentially using radix sort with variable-length keys. The trick is that shorter strings can be thought of as longer strings with special padding characters, allowing us to use the standard radix sort algorithm.
{% endcapture %}
{% include aside.html title='Variable-Length Radix Sort' %}
