---
title:       Exercise 10.2-2
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "stack, singly linked list, push, pop"
description: "Implement a stack using a singly linked list L. The operations PUSH and POP should still take O(1) time."
---

> Implement a stack using a singly linked list $$L$$. The operations $$\textsc{Push}$$ and $$\textsc{Pop}$$ should still take $$O(1)$$ time.

A stack supports operations only at one end (the top), which makes it perfect for a singly linked list. We can use the head of the list as the top of the stack. Pushing adds an element at the head, and popping removes an element from the head. Since a singly linked list allows $$O(1)$$-time insertion and deletion at the head, both stack operations will be efficient.

{% capture code %}
STACK-EMPTY(S)
    if S.head == NIL
        return TRUE
    else
        return FALSE

PUSH(S, x)
    x.next = S.head
    S.head = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    x = S.head
    S.head = S.head.next
    return x
{% endcapture %}
{% include clrs_code.html %}

All three operations run in $$O(1)$$ time:

- $$\textsc{Stack-Empty}$$ just checks if the head pointer is $$\textsc{Nil}$$.
- $$\textsc{Push}$$ creates a new node and updates two pointers.
- $$\textsc{Pop}$$ saves the head node, updates the head pointer, and returns the saved node.

None of these operations depend on the size of the stack, so they all take constant time.

This implementation is actually simpler than the array-based stack because we don't need to track a $$\textit{top}$$ index, and we never have to worry about stack overflow (as long as we have memory available for new nodes).
