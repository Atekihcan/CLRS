---
title:       Exercise 10.2-6
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "union, linked lists, dynamic sets"
description: "The dynamic-set operation UNION takes two disjoint sets S₁ and S₂ as input, and it returns a set S = S₁ ∪ S₂ consisting of all the elements of S₁ and S₂. The sets S₁ and S₂ are usually destroyed by the operation. Show how to support UNION in O(1) time using a suitable list data structure."
---

> The dynamic-set operation $$\textsc{Union}$$ takes two disjoint sets $$S_1$$ and $$S_2$$ as input, and it returns a set $$S = S_1 \cup S_2$$ consisting of all the elements of $$S_1$$ and $$S_2$$. The sets $$S_1$$ and $$S_2$$ are usually destroyed by the operation. Show how to support $$\textsc{Union}$$ in $$O(1)$$ time using a suitable list data structure.

The key to achieving $$O(1)$$ time is to avoid traversing either list. We can accomplish this by simply concatenating the two lists, which requires updating only a constant number of pointers.

If we use doubly linked lists with both $$\textit{head}$$ and $$\textit{tail}$$ pointers, we can link the tail of $$S_1$$ to the head of $$S_2$$ in constant time:

{% capture code %}
UNION(S₁, S₂)
    if S₁.head == NIL
        return S₂
    if S₂.head == NIL
        return S₁
    // Link tail of S₁ to head of S₂
    S₁.tail.next = S₂.head
    S₂.head.prev = S₁.tail
    // Update tail pointer
    S₁.tail = S₂.tail
    return S₁
{% endcapture %}
{% include clrs_code.html %}

This operation performs only a constant number of pointer updates:
1. Link $$S_1.\textit{tail}.\textit{next}$$ to $$S_2.\textit{head}$$
2. Link $$S_2.\textit{head}.\textit{prev}$$ to $$S_1.\textit{tail}$$
3. Update $$S_1.\textit{tail}$$ to point to $$S_2.\textit{tail}$$

Therefore, $$\textsc{Union}$$ runs in $$O(1)$$ time.

We could also use singly linked lists if we maintain a $$\textit{tail}$$ pointer:

{% capture code %}
UNION-SINGLY(S₁, S₂)
    if S₁.head == NIL
        return S₂
    if S₂.head == NIL
        return S₁
    // Link tail of S₁ to head of S₂
    S₁.tail.next = S₂.head
    S₁.tail = S₂.tail
    return S₁
{% endcapture %}
{% include clrs_code.html %}

{% capture note %}
The requirement that $$S_1$$ and $$S_2$$ be disjoint (no common elements) is not actually needed for this implementation to work correctly in $$O(1)$$ time. The operation will concatenate the lists regardless of whether they share elements. However, the mathematical definition of set union assumes disjoint sets to avoid duplicates.

If we only maintained a $$\textit{head}$$ pointer (without a $$\textit{tail}$$ pointer), we would need $$O(n_1)$$ time to find the tail of $$S_1$$ by traversing the entire list, where $$n_1 = |S_1|$$.
{% endcapture %}
{% include aside.html title='Why Tail Pointers Matter' %}
