---
title:       Problem 9-1
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "order statistics, sorting, priority queue, selection, largest elements"
description: "Given a set of n numbers, we wish to find the i largest in sorted order using a comparison-based algorithm. Find the algorithm that implements each of the following methods with the best asymptotic worst-case running time, and analyze the running times of the algorithms in terms of n and i."
---

> **Largest $$i$$ numbers in sorted order**
>
> Given a set of $$n$$ numbers, we wish to find the $$i$$ largest in sorted order using a comparison-based algorithm. Find the algorithm that implements each of the following methods with the best asymptotic worst-case running time, and analyze the running times of the algorithms in terms of $$n$$ and $$i$$.
>
> 1. Sort the numbers, and list the $$i$$ largest.
> 2. Build a max-priority queue from the numbers, and call $$\textsc{Extract-Max}$$ $$i$$ times.
> 3. Use an order-statistic algorithm to find the $$i$$th largest number, partition around that number, and sort the $$i$$ largest numbers.

### A.

Use any optimal comparison-based sorting algorithm such as heapsort or merge sort to sort all $$n$$ elements in $$O(n \lg n)$$ time. Then output the last $$i$$ elements of the sorted array in $$O(i)$$ time.

**Total time:** $$O(n \lg n)$$

This method is simple but does more work than necessary when $$i \ll n$$, since we sort all $$n$$ elements even though we only need the $$i$$ largest.

### B.

Build a max-heap from the $$n$$ elements using $$\textsc{Build-Max-Heap}$$ in $$O(n)$$ time. Then call $$\textsc{Extract-Max}$$ $$i$$ times, where each extraction takes $$O(\lg n)$$ time. The extracted elements come out in sorted order (largest first).

**Total time:** $$O(n + i \lg n)$$

This is better than method A when $$i = O(n / \lg n)$$, because we avoid the full $$O(n \lg n)$$ sort. For small $$i$$, the $$O(n)$$ heap building dominates, giving near-linear performance.

{% include ads.html %}

### C.

Use $$\textsc{Select}$$ to find the $$i$$th largest element (the $$(n - i + 1)$$th smallest) in $$O(n)$$ worst-case time. Then use a modified $$\textsc{Partition}$$ to rearrange the array so all elements greater than or equal to this value are on one side in $$O(n)$$ time. Finally, sort these $$i$$ elements using an optimal sorting algorithm in $$O(i \lg i)$$ time.

**Total time:** $$O(n + i \lg i)$$

This is the best of the three methods for small to moderate $$i$$. The linear-time selection and partitioning avoid the $$n \lg n$$ cost of sorting all elements, and we only pay $$O(i \lg i)$$ to sort the $$i$$ elements we actually need.

**Comparison:**

- For $$i = O(1)$$: Method C is $$O(n)$$, method B is $$O(n)$$, method A is $$O(n \lg n)$$
- For $$i = \Theta(\sqrt{n})$$: Method C is $$O(n)$$, method B is $$O(n \lg n)$$, method A is $$O(n \lg n)$$
- For $$i = \Theta(n)$$: All three methods are $$O(n \lg n)$$

Method C is optimal or near-optimal across all ranges of $$i$$, while methods A and B are better suited for specific ranges (A for $$i = \Theta(n)$$, B for small $$i$$ with simple implementation).
