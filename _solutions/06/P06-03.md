---
title:       Problem 6-3
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "Young tableau, extract-min, insert, sorting, matrix search"
description: "Young tableaus"
---

An $$m \times n$$ **Young tableau** is an $$m \times n$$ matrix such that the entries of each row are in sorted order from left to right and the entries of each column are in sorted order from top to bottom. Some of the entries of a Young tableau may be $$\infty$$, which we treat as nonexistent elements. Thus, a Young tableau can be used to hold $$r \leq mn$$ finite numbers.

### 1.

We need to arrange the elements {9, 16, 3, 2, 4, 8, 5, 14, 12} in a $$4 \times 4$$ matrix such that rows increase left to right and columns increase top to bottom.

Starting with the smallest element, 2, we place it in the top-left corner. Then we insert the remaining elements one by one. A valid $$4 \times 4$$ Young tableau is:

$$\begin{array}{|c|c|c|c|}
\hline
2 & 3 & 4 & 5 \\
\hline
8 & 9 & 12 & 14 \\
\hline
16 & \infty & \infty & \infty \\
\hline
\infty & \infty & \infty & \infty \\
\hline
\end{array}$$

We can verify this is valid: each row increases from left to right (2 < 3 < 4 < 5, etc.), and each column increases from top to bottom (2 < 8 < 16 < $$\infty$$, etc.).

{% capture note %}
There isn't a unique Young tableau for a given set of elements. Different insertion orders can produce different valid tableaus. The tableau shown above is just one possible arrangement.
{% endcapture %}
{% include aside.html title='Multiple valid tableaus exist' %}

### 2.

Think about what the ordering properties tell us. If $$Y[1,1] = \infty$$, then since every element in the first row must be at least as large as $$Y[1,1]$$ (rows increase left to right), we have $$Y[1,j] = \infty$$ for all $$j$$. Similarly, since every element in the first column must be at least as large as $$Y[1,1]$$ (columns increase top to bottom), we have $$Y[i,1] = \infty$$ for all $$i$$.

But now consider any element $$Y[i,j]$$ with $$i, j > 1$$. We have $$Y[i,j] \geq Y[i,1] = \infty$$ (since columns increase), so $$Y[i,j] = \infty$$. By induction, all elements in the tableau are $$\infty$$, meaning the tableau is empty.

For the second part, if $$Y[m,n] < \infty$$, then $$Y[m,n]$$ is a finite number. Since rows increase left to right, every element in row $$m$$ is finite: $$Y[m,j] \leq Y[m,n] < \infty$$ for all $$j \leq n$$. Similarly, since columns increase top to bottom, every element in column $$n$$ is finite: $$Y[i,n] \leq Y[m,n] < \infty$$ for all $$i \leq m$$.

Now consider any element $$Y[i,j]$$. We have $$Y[i,j] \leq Y[i,n] < \infty$$ (row increases) and $$Y[i,j] \leq Y[m,j] < \infty$$ (column increases). Therefore, every element in the tableau is finite, meaning the tableau contains exactly $$mn$$ elements and is full.

{% include ads.html %}

### 3.

The minimum element in a Young tableau is always at position $$[1,1]$$ because it's smaller than everything in its row and column, which in turn are smaller than everything else in the tableau.

After extracting $$Y[1,1]$$, we need to fill the hole. We replace $$Y[1,1]$$ with $$\infty$$ and then "sink" this $$\infty$$ down to its proper position, similar to $$\textsc{Max-Heapify}$$ but adapted to the two-dimensional structure.

{% capture code %}
YOUNG-EXTRACT-MIN(Y)
    min = Y[1, 1]
    Y[1, 1] = ∞
    YOUNG-HEAPIFY(Y, 1, 1)
    return min

YOUNG-HEAPIFY(Y, i, j)
    // Find the minimum among current position, right neighbor, and bottom neighbor
    min_i = i
    min_j = j

    // Check right neighbor
    if j < n and Y[i, j + 1] < Y[min_i, min_j]
        min_i = i
        min_j = j + 1

    // Check bottom neighbor
    if i < m and Y[i + 1, j] < Y[min_i, min_j]
        min_i = i + 1
        min_j = j

    // If we found a smaller neighbor, swap and recurse
    if min_i ≠ i or min_j ≠ j
        exchange Y[i, j] with Y[min_i, min_j]
        YOUNG-HEAPIFY(Y, min_i, min_j)
{% endcapture %}
{% include clrs_code.html %}

At each step, we compare at most 3 elements (current position and two neighbors) and swap with one of them, moving either right or down. Let $$T(p)$$ be the maximum running time for a tableau where $$p = m + n$$.

After one step, we recurse on either an $$(m-1) \times n$$ tableau (if we moved down) or an $$m \times (n-1)$$ tableau (if we moved right). In both cases, the new parameter is $$(m-1) + n$$ or $$m + (n-1) = p - 1$$.

This gives us the recurrence:

$$T(p) = T(p-1) + O(1)$$

Solving this recurrence:

$$\begin{align*}
T(p) &= T(p-1) + O(1) \\
     &= T(p-2) + O(1) + O(1) \\
     &= \cdots \\
     &= T(1) + O(p) \\
     &= O(p) \\
     &= O(m + n)
\end{align*}$$

Therefore, $$\textsc{Extract-Min}$$ runs in $$O(m + n)$$ time.

{% include ads.html %}

### 4.

To insert a new element, we use the opposite strategy from extraction. We place the new element at position $$[m,n]$$ (replacing the $$\infty$$ there in a nonfull tableau) and then "bubble" it up and left to its proper position.

{% capture code %}
YOUNG-INSERT(Y, key)
    if Y[m, n] < ∞
        error "tableau is full"
    Y[m, n] = key
    YOUNG-BUBBLE-UP(Y, m, n)

YOUNG-BUBBLE-UP(Y, i, j)
    // Find the maximum among current position, left neighbor, and top neighbor
    max_i = i
    max_j = j

    // Check left neighbor
    if j > 1 and Y[i, j - 1] > Y[max_i, max_j]
        max_i = i
        max_j = j - 1

    // Check top neighbor
    if i > 1 and Y[i - 1, j] > Y[max_i, max_j]
        max_i = i - 1
        max_j = j

    // If we found a larger neighbor, swap and recurse
    if max_i ≠ i or max_j ≠ j
        exchange Y[i, j] with Y[max_i, max_j]
        YOUNG-BUBBLE-UP(Y, max_i, max_j)
{% endcapture %}
{% include clrs_code.html %}

The analysis is symmetric to $$\textsc{Extract-Min}$$. At each step, we move either up or left, reducing either $$i$$ or $$j$$ by 1. Starting from position $$[m,n]$$ and moving to position $$[1,1]$$ requires at most $$m-1 + n-1 = m + n - 2$$ moves.

Therefore, $$\textsc{Young-Insert}$$ runs in $$O(m + n)$$ time.

{% capture note %}
The duality between insertion and extraction is elegant: extraction removes the minimum from $$[1,1]$$ and sinks $$\infty$$ toward $$[m,n]$$, while insertion places a new value at $$[m,n]$$ and bubbles it toward $$[1,1]$$. Both operations maintain the Young tableau properties.
{% endcapture %}
{% include aside.html title='Symmetric operations' %}

### 5.

To sort $$n^2$$ numbers using an $$n \times n$$ Young tableau, we first insert all $$n^2$$ numbers into an initially empty tableau, then extract them one by one in sorted order.

The algorithm is:

1. Initialize an $$n \times n$$ Young tableau with all entries set to $$\infty$$.
2. For each of the $$n^2$$ numbers, call $$\textsc{Young-Insert}$$ to insert it into the tableau.
3. For $$i = 1$$ to $$n^2$$, call $$\textsc{Young-Extract-Min}$$ and store the result in position $$i$$ of the output array.

Each insertion takes $$O(n + n) = O(n)$$ time, and we perform $$n^2$$ insertions, giving $$O(n^3)$$ time for step 2. Each extraction takes $$O(n)$$ time, and we perform $$n^2$$ extractions, giving $$O(n^3)$$ time for step 3.

Therefore, the total running time is $$O(n^3) + O(n^3) = O(n^3)$$.

{% include ads.html %}

### 6.

To search for a value $$x$$ in a Young tableau, we can exploit the ordering properties. Starting from the top-right corner at position $$[1,n]$$, we can eliminate either an entire row or an entire column at each step.

The key observation is that at position $$[i,j]$$:
- All elements to the left in row $$i$$ are smaller than $$Y[i,j]$$
- All elements below in column $$j$$ are larger than $$Y[i,j]$$

So if $$x < Y[i,j]$$, we know $$x$$ cannot be anywhere in column $$j$$ (since all elements in that column below $$[i,j]$$ are even larger). If $$x > Y[i,j]$$, we know $$x$$ cannot be anywhere in row $$i$$ to the left of position $$j$$.

{% capture code %}
YOUNG-SEARCH(Y, x)
    i = 1
    j = n
    while i ≤ m and j ≥ 1
        if Y[i, j] = x
            return (i, j)
        else if Y[i, j] > x
            j = j - 1    // eliminate column j
        else
            i = i + 1    // eliminate row i
    return NIL
{% endcapture %}
{% include clrs_code.html %}

We start at position $$[1,n]$$ and move either down (incrementing $$i$$) or left (decrementing $$j$$) at each step. We can move down at most $$m-1$$ times and left at most $$n-1$$ times, so the total number of steps is at most $$(m-1) + (n-1) = m + n - 2$$.

Therefore, the algorithm runs in $$O(m + n)$$ time.

{% capture note %}
This search algorithm is similar to searching in a sorted matrix and demonstrates how the two-dimensional ordering constraints of a Young tableau enable efficient operations. The technique of starting from a corner and eliminating rows or columns is a classic approach for searching in sorted matrices.
{% endcapture %}
{% include aside.html title='Searching in two dimensions' %}
