---
title:       Exercise 8.2-2
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "counting sort, stability, stable sort, proof"
description: "Prove that COUNTING-SORT is stable."
---

> Prove that $$\textsc{Counting-Sort}$$ is stable.

A sorting algorithm is stable if elements with equal values appear in the output in the same relative order as they appeared in the input. Let's prove that counting sort has this property.

Consider two elements $$A[i]$$ and $$A[j]$$ where $$i < j$$ (so $$A[i]$$ appears before $$A[j]$$ in the input) and $$A[i] = A[j] = v$$ for some value $$v$$.

The key to the proof is understanding what happens in the final loop (lines 10-12), which processes elements from right to left.

After lines 7-8, $$C[v]$$ contains the total count of elements with values less than or equal to $$v$$. This tells us the final position range for all elements equal to $$v$$.

Since the loop processes elements from $$A[n]$$ down to $$A[1]$$:

1. Element $$A[j]$$ is encountered first (remember $$j > i$$)
2. When we process $$A[j] = v$$, we place it at position $$C[v]$$ in the output array $$B$$
3. We then decrement $$C[v]$$ (line 12)
4. Later, when we process $$A[i] = v$$, it gets placed at the new value of $$C[v]$$, which is one position to the left of where $$A[j]$$ was placed

Since $$A[j]$$ appears later in the input but is processed first in the backward loop, it goes into a higher index position in $$B$$. Then $$A[i]$$ goes into a lower index position. This means $$A[i]$$ appears before $$A[j]$$ in the sorted output, preserving their relative order from the input.

This holds for any pair of equal elements, proving that counting sort is stable.

{% capture note %}
The backward iteration (lines 10-12) is crucial for stability. If we iterated forward, elements would be placed in reverse order, and the algorithm would not be stable. Exercise 8.2-3 explores this variation.
{% endcapture %}
{% include aside.html title='Why Backward Iteration?' %}
