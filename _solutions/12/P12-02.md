---
title:       Problem 12-2
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "radix tree, binary strings, sorting, lexicographic order"
description: "Given two strings a and b, we say that string a is lexicographically less than string b based on specific rules. Use a radix tree to sort a set S of distinct bit strings whose lengths sum to n in Θ(n) time."
---

> **Radix trees**
>
> Given two strings $$a = a_0a_1 \ldots a_p$$ and $$b = b_0b_1 \ldots b_q$$, where each $$a_i$$ and each $$b_j$$ is in some ordered set of characters, we say that string $$a$$ is **lexicographically less than** string $$b$$ if either
>
> 1. there exists an integer $$j$$, where $$0 \le j \le \min(p,q)$$, such that $$a_i = b_i$$ for all $$i = 0, 1, \ldots, j-1$$ and $$a_j < b_j$$, or
> 2. $$p < q$$ and $$a_i = b_i$$ for all $$i = 0, 1, \ldots, p$$.
>
> For example, if $$a$$ and $$b$$ are bit strings, then $$10100 < 10110$$ by rule 1 (letting $$j = 3$$) and $$10100 < 101000$$ by rule 2. This ordering is similar to that used in English-language dictionaries.
>
> The radix tree data structure shown in Figure 12.5 stores the bit strings 1011, 10, 011, 100, and 0. When searching for a key $$a = a_0a_1 \ldots a_p$$, we go left at a node of depth $$i$$ if $$a_i = 0$$ and right if $$a_i = 1$$. Let $$S$$ be a set of distinct bit strings whose lengths sum to $$n$$. Show how to use a radix tree to sort $$S$$ lexicographically in $$\Theta(n)$$ time. For the example in Figure 12.5, the output of the sort should be the sequence 0, 011, 10, 100, 1011.

A radix tree for bit strings is a binary tree where:
- At each node of depth $$i$$, we decide based on the $$i$$-th bit
- Go left if bit $$i$$ is 0, go right if bit $$i$$ is 1
- Leaf nodes (or nodes marked as endpoints) represent complete strings

### Algorithm: Sorting with Radix Tree

**Phase 1: Build the radix tree** ($$O(n)$$ time)

Insert each string into the radix tree by following bits from left to right:

{% capture code %}
RadixTreeInsert(T, s)
    x = T.root
    for i = 0 to length(s) - 1
        if s[i] == 0
            if x.left == NIL
                create new node x.left
            x = x.left
        else  // s[i] == 1
            if x.right == NIL
                create new node x.right
            x = x.right
    x.isString = true
    x.value = s
{% endcapture %}
{% include clrs_code.html title='RadixTreeInsert(T, s)' %}

**Time for building:** Each bit is examined exactly once. Total bits = $$n$$, so building takes $$\Theta(n)$$ time.

**Phase 2: Inorder traversal** ($$O(n)$$ time)

Perform an inorder tree walk, printing strings when we encounter nodes marked as string endpoints:

{% capture code %}
RadixTreeInorderWalk(x)
    if x == NIL
        return
    RadixTreeInorderWalk(x.left)
    if x.isString == true
        print x.value
    RadixTreeInorderWalk(x.right)
{% endcapture %}
{% include clrs_code.html title='RadixTreeInorderWalk(x)' %}

**Why inorder produces lexicographic order:**

1. Strings starting with 0 (left subtree) are visited before strings starting with 1 (right subtree)
2. Within the left subtree, shorter strings are visited before longer strings (because we print when encountering the endpoint marker)
3. Among strings with the same prefix, the lexicographically smaller one is in the left subtree

**Time for traversal:** Each node in the radix tree corresponds to a prefix of some string. The total number of nodes is at most $$n + |S|$$ where $$|S|$$ is the number of strings (since we add at most one node per bit, plus one node per string endpoint). Since $$|S| \le n$$, traversal takes $$O(n)$$ time.

### Example from Figure 12.5

Strings: {1011, 10, 011, 100, 0}

After building radix tree and performing inorder traversal:

```
Visit left subtree of root (bit 0):
  - Visit "0" (found endpoint)
  - Visit "011" (continue down: left at bit 1, right at bit 2, right at bit 3)
Visit root (no string here)
Visit right subtree of root (bit 1):
  - Visit left subtree (bit 0 after first 1):
    - Visit "10" (found endpoint at depth 2)
    - Visit "100" (continue down: left at bit 2)
  - Visit right subtree (bit 1 after first 1):
    - Visit "1011"
```

**Output:** 0, 011, 10, 100, 1011 ✓

This is the correct lexicographic order!

### Time Complexity Analysis

**Total time:** $$\Theta(n)$$

- Building the radix tree: Process each of the $$n$$ bits exactly once = $$\Theta(n)$$
- Inorder traversal: Visit $$O(n)$$ nodes = $$O(n)$$

Therefore, we can sort $$S$$ in $$\Theta(n)$$ time, which is optimal since we must at least read all $$n$$ bits.

{% capture note %}
**Advantages of radix tree sorting:**

1. **Linear time:** $$\Theta(n)$$ is better than comparison-based sorting's $$\Omega(n \lg n)$$ lower bound
2. **Works for variable-length strings:** Unlike some radix sort variants that require fixed-length keys
3. **Handles common prefixes efficiently:** Shared prefixes are stored only once in the tree

**Limitation:** Only works for strings over a small alphabet (like binary strings). For larger alphabets, each node would need many children, increasing space complexity.

This is similar to other linear-time sorting algorithms like counting sort or bucket sort, which exploit special properties of the input (in this case, the binary alphabet and total bit length).
{% endcapture %}
{% include aside.html title='Radix tree sorting vs comparison-based sorting' %}
