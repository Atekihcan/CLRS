---
title:       Exercise 6.5-8
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "heap-delete, priority queue operations, max-heap, heap operations"
description: "The operation HEAP-DELETE(A, i) deletes the item in node i from heap A. Give an implementation of HEAP-DELETE that runs in O(lg n) time for an n-element max-heap."
---

> The operation $$\textsc{Heap-Delete}(A, i)$$ deletes the item in node $$i$$ from heap $$A$$. Give an implementation of $$\textsc{Heap-Delete}$$ that runs in $$O(\lg n)$$ time for an $$n$$-element max-heap.

Deleting an arbitrary element from a heap is similar to $$\textsc{Heap-Extract-Max}$$, except we're removing from any position rather than just the root. The strategy is to replace the element to be deleted with the last element in the heap, then restore the heap property.

The key insight is that after replacement, the heap property might be violated in two ways:

1. The new value might be too large (larger than its parent), requiring upward movement
2. The new value might be too small (smaller than its children), requiring downward movement

We can handle both cases efficiently.

{% capture code %}
if i > A.heapsize
    error "index out of bounds"
if i == A.heapsize
    A.heapsize = A.heapsize - 1
    return
A[i] = A[A.heapsize]
A.heapsize = A.heapsize - 1
if i > 1 and A[i] > A[Parent(i)]
    Heap-Increase-Key(A, i, A[i])
else
    Max-Heapify(A, i)
{% endcapture %}
{% include clrs_code.html title="Heap-Delete(A, i)" %}

{% include ads.html %}

### Why This Works

After replacing $$A[i]$$ with the last element, exactly one of three situations occurs:

1. **The heap property is already satisfied** at position $$i$$ (the replacement value happens to fit perfectly)
2. **The new value is too large** compared to its parent (violates the max-heap property upward)
3. **The new value is too small** compared to its children (violates the max-heap property downward)

The conditional on line 8 distinguishes case 2 from case 3. If neither condition is met, $$\textsc{Max-Heapify}$$ handles case 3 (and does nothing for case 1).

### Time Complexity

The running time is $$O(\lg n)$$ because:

- The replacement and comparison operations take $$O(1)$$ time
- Either $$\textsc{Heap-Increase-Key}$$ or $$\textsc{Max-Heapify}$$ is called, each taking $$O(\lg n)$$ time

{% capture note %}
An alternative implementation can be always calling $$\textsc{Heap-Increase-Key}(A, i, \infty)$$ to bubble the element to the root, then calling $$\textsc{Heap-Extract-Max}$$. It will be a simpler implemenetation but it makes two passes through the heap instead of one. Our implementation is more efficient in practice.
{% endcapture %}
{% include aside.html title='Alternative Approach' %}
