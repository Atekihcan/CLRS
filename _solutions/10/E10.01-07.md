---
title:       Exercise 10.1-7
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "stack, queues, amortized analysis"
description: "Show how to implement a stack using two queues. Analyze the running time of the stack operations."
---

> Show how to implement a stack using two queues. Analyze the running time of the stack operations.

Implementing a stack using two queues is trickier than implementing a queue using two stacks. The challenge is that a queue is FIFO (first in, first out) while a stack is LIFO (last in, first out). We need to reverse the order somehow.

The key insight is to use one queue ($$Q_1$$) to store the stack elements and another queue ($$Q_2$$) as temporary storage during pop operations. When we push an element, we add it to $$Q_1$$. When we pop, we need to remove the most recently added element, which is at the back of $$Q_1$$. To access it, we dequeue all but the last element from $$Q_1$$ and enqueue them into $$Q_2$$, then dequeue the last element from $$Q_1$$. Finally, we swap the names of $$Q_1$$ and $$Q_2$$.

{% capture code %}
PUSH(S, x)
    ENQUEUE(S.Q₁, x)

POP(S)
    if QUEUE-EMPTY(S.Q₁)
        error "underflow"
    // Move all but last element to Q₂
    while S.Q₁ has more than 1 element
        x = DEQUEUE(S.Q₁)
        ENQUEUE(S.Q₂, x)
    // Last element is what we want to pop
    result = DEQUEUE(S.Q₁)
    // Swap Q₁ and Q₂
    swap S.Q₁ with S.Q₂
    return result
{% endcapture %}
{% include clrs_code.html %}

### Running Time Analysis

$$\textsc{Push}$$ performs a single $$\textsc{Enqueue}$$ operation, taking $$O(1)$$ time.

$$\textsc{Pop}$$ must move $$n - 1$$ elements from $$Q_1$$ to $$Q_2$$ (where $$n$$ is the current number of elements in the stack), then dequeue the last element. Each element movement involves one dequeue and one enqueue, both $$O(1)$$ operations. Therefore, $$\textsc{Pop}$$ takes $$\Theta(n)$$ time in the worst case.

Unlike the two-stack queue implementation (which had $$O(1)$$ amortized time for all operations), this two-queue stack implementation has genuinely expensive pop operations. Each element gets moved from $$Q_1$$ to $$Q_2$$ every time we perform a pop after pushing it. If we perform $$m$$ pushes followed by $$m$$ pops, the total work is:

$$\begin{align*}
\text{Total cost} &= m \times O(1) + \sum_{i=1}^{m} O(i) \\
&= O(m) + O(m^2) \\
&= O(m^2)
\end{align*}$$

This gives an average cost of $$O(m^2/m) = O(m)$$ per operation, which is not constant time even in the amortized sense.

{% capture note %}
This implementation shows that while we can technically implement a stack using two queues, it's not efficient. The asymmetry between stacks and queues means that using two stacks to implement a queue works well ($$O(1)$$ amortized), but using two queues to implement a stack is inefficient ($$\Theta(n)$$ per pop).
{% endcapture %}
{% include aside.html title='Why This is Inefficient' %}
