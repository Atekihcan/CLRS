---
title:       Exercise 12.2-2
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, tree minimum, tree maximum, recursive algorithm"
description: "Write recursive versions of TREE-MINIMUM and TREE-MAXIMUM."
---

> Write recursive versions of $$\textsc{Tree-Minimum}$$ and $$\textsc{Tree-Maximum}$$.

The iterative versions use loops to follow left (or right) pointers. The recursive versions replace the loops with recursive calls.

### Recursive Tree-Minimum

To find the minimum in a BST rooted at $$x$$, we recursively go left until we find a node with no left child.

{% capture code %}
RecursiveTreeMinimum(x)
    if x.left == NIL
        return x
    else
        return RecursiveTreeMinimum(x.left)
{% endcapture %}
{% include clrs_code.html title='RecursiveTreeMinimum(x)' %}

The algorithm works because the binary-search-tree property guarantees that the leftmost node (the node with no left child) contains the minimum key in the subtree.

### Recursive Tree-Maximum

Symmetrically, to find the maximum in a BST rooted at $$x$$, we recursively go right until we find a node with no right child.

{% capture code %}
RecursiveTreeMaximum(x)
    if x.right == NIL
        return x
    else
        return RecursiveTreeMaximum(x.right)
{% endcapture %}
{% include clrs_code.html title='RecursiveTreeMaximum(x)' %}

{% include ads.html %}

The rightmost node (the node with no right child) contains the maximum key in the subtree.

### Correctness

Both procedures are correct by the binary-search-tree property:

For $$\textsc{Recursive-Tree-Minimum}$$:
- If $$x$$ has no left child, then no keys in the tree are smaller than $$x.\textit{key}$$, so $$x$$ contains the minimum
- If $$x$$ has a left child, then the minimum must be in the left subtree (since all keys there are $$\le x.\textit{key}$$), so we recurse left

For $$\textsc{Recursive-Tree-Maximum}$$:
- If $$x$$ has no right child, then no keys in the tree are larger than $$x.\textit{key}$$, so $$x$$ contains the maximum
- If $$x$$ has a right child, then the maximum must be in the right subtree (since all keys there are $$\ge x.\textit{key}$$), so we recurse right

### Time Complexity

Both algorithms run in $$O(h)$$ time on a tree of height $$h$$, where $$h$$ is the length of the path from the root to the minimum/maximum node. This matches the iterative versions.

{% capture note %}
The iterative versions are generally preferred in practice because:
1. They avoid function call overhead
2. They use $$O(1)$$ space instead of $$O(h)$$ stack space
3. Tail recursion optimization could eliminate the stack overhead in the recursive versions, but not all compilers perform this optimization

However, the recursive versions are more concise and easier to understand conceptually.
{% endcapture %}
{% include aside.html title='Recursive vs iterative implementations' %}
