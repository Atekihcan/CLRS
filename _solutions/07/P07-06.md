---
title:       Problem 7-6
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "fuzzy sorting, intervals, quicksort, overlapping ranges"
description: "Fuzzy sorting of intervals: Consider a sorting problem in which we do not know the numbers exactly. Instead, for each number, we know an interval on the real line to which it belongs."
---

> **Fuzzy sorting of intervals**
>
> Consider a sorting problem in which we do not know the numbers exactly. Instead, for each number, we know an interval on the real line to which it belongs. That is, we are given $$n$$ closed intervals of the form $$[a_i, b_i]$$, where $$a_i \leq b_i$$. We wish to *fuzzy-sort* these intervals, i.e., to produce a permutation $$\langle i_1, i_2, \ldots, i_n \rangle$$ of the intervals such that for $$j = 1, 2, \ldots, n$$, there exist $$c_j \in [a_{i_j}, b_{i_j}]$$ satisfying $$c_1 \leq c_2 \leq \cdots \leq c_n$$.
>
> 1. Design a randomized algorithm for fuzzy-sorting $$n$$ intervals. Your algorithm should have the general structure of an algorithm that quicksorts the left endpoints (the $$a_i$$ values), but it should take advantage of overlapping intervals to improve the running time. (As the intervals overlap more and more, the problem of fuzzy-sorting the intervals becomes progressively easier. Your algorithm should take advantage of such overlapping, to the extent that it exists.)
> 2. Argue that your algorithm runs in expected time $$\Theta(n \lg n)$$ in general, but runs in expected time $$\Theta(n)$$ when all of the intervals overlap (i.e., when there exists a value $$x$$ such that $$x \in [a_i, b_i]$$ for all $$i$$). Your algorithm should not be checking for this case explicitly; rather, its performance should naturally improve as the amount of overlap increases.

Fuzzy sorting generalizes traditional sorting to handle imprecise data represented as intervals. The key insight is that overlapping intervals can be grouped together, reducing the problem size.

### A.

The algorithm adapts quicksort's partitioning to exploit interval overlap. Instead of partitioning around a single value, we partition around an interval.

{% capture code %}
Fuzzy-Sort(I, p, r)
    if p < r
        (q, t) = Fuzzy-Partition(I, p, r)
        Fuzzy-Sort(I, p, q - 1)
        Fuzzy-Sort(I, t + 1, r)
{% endcapture %}
{% include clrs_code.html title="Fuzzy-Sort(I, p, r)" %}

{% capture code2 %}
Fuzzy-Partition(I, p, r)
    // Select random pivot interval
    i = Random(p, r)
    swap I[r] with I[i]
    pivot = I[r]

    // Find the overlapping region with pivot
    left = pivot.a
    right = pivot.b

    // Partition intervals
    less = p - 1      // End of intervals completely to the left
    equal = p - 1     // End of intervals overlapping pivot
    j = p

    while j â‰¤ r
        if I[j].b < left
            // I[j] is completely to the left of pivot
            less = less + 1
            equal = equal + 1
            swap I[less] with I[j]
            if less != equal
                swap I[j] with I[equal]
            j = j + 1
        else if I[j].a > right
            // I[j] is completely to the right of pivot
            j = j + 1
        else
            // I[j] overlaps with pivot, merge the overlap
            equal = equal + 1
            swap I[equal] with I[j]
            // Update the common overlapping region
            left = max(left, I[j].a)
            right = min(right, I[j].b)
            j = j + 1

    return (less + 1, equal)
{% endcapture %}
{% include clrs_code.html title="Fuzzy-Partition(I, p, r)" %}

**How it works:**

1. Select a random interval as the pivot
2. Partition intervals into three groups:
   - **Left:** intervals completely before the pivot's left endpoint
   - **Overlapping:** intervals that overlap with the pivot
   - **Right:** intervals completely after the pivot's right endpoint

3. As we identify overlapping intervals, we track the common overlap region $$[left, right]$$. This shrinks as we find the intersection of all overlapping intervals.

4. Return indices separating the three groups: $$(q, t)$$ where $$I[p..q-1]$$ are left intervals, $$I[q..t]$$ overlap, and $$I[t+1..r]$$ are right intervals.

5. Recursively sort only the left and right groups. The overlapping group is already correctly positioned (they can all take values from their common intersection).

{% include ads.html %}

### B.

**General case: $$\Theta(n \lg n)$$**

When intervals have minimal overlap, fuzzy-sort behaves like standard quicksort:
- Each partition operation takes $$O(n)$$ time
- With random pivot selection, we expect balanced partitions
- Recursion depth is $$O(\lg n)$$
- Total time: $$O(n \lg n)$$

**When all intervals overlap: $$\Theta(n)$$**

Suppose there exists a point $$x$$ such that $$x \in [a_i, b_i]$$ for all $$i$$. Then:

1. **First partition:** The pivot interval contains $$x$$. Every other interval also contains $$x$$, so all intervals overlap with the pivot.
2. **All intervals grouped together:** After one partition, all $$n$$ intervals are identified as overlapping and placed in the middle group $$I[q..t]$$ where $$t = r$$.
3. **No recursion needed:** Since $$q = 1$$ and $$t = n$$, there are no left or right subgroups to sort.
4. **Total time:** One partition pass through $$n$$ intervals takes $$\Theta(n)$$ time.

**Intermediate cases:**

As overlap increases, more intervals get grouped together in each partition, reducing the recursion tree size. If each partition groups $$k$$ intervals on average:
- Effective problem size reduces by factor of $$k$$
- Recursion depth becomes $$\lg(n/k)$$
- Total time: $$O(n \lg(n/k))$$

When $$k = n$$ (complete overlap), this reduces to $$O(n \lg 1) = O(n)$$.

**Why the algorithm naturally adapts:**

The algorithm doesn't explicitly check for overlap. Instead:
- More overlap $$\Rightarrow$$ larger overlapping groups $$\Rightarrow$$ fewer recursive calls
- Complete overlap $$\Rightarrow$$ all intervals grouped in one partition $$\Rightarrow$$ no recursion
- The performance improvement emerges naturally from the partitioning logic

This elegant property makes fuzzy-sort adaptive to the input structure without requiring explicit detection mechanisms.

{% capture note %}
Fuzzy sorting has practical applications in computational geometry (sorting imprecise measurements), database query optimization (range queries), and scheduling (tasks with flexible time windows). The algorithm's ability to automatically exploit structure in the input makes it particularly valuable for real-world imprecise data.
{% endcapture %}
{% include aside.html title='Applications of fuzzy sorting' %}
