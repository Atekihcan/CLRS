---
title:       Problem 8-7
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "0-1 sorting lemma, columnsort, oblivious algorithm, comparison-exchange, sorting network"
description: "The 0-1 sorting lemma and columnsort"
---

> **The 0-1 sorting lemma and columnsort**
>
> This problem involves proving the 0-1 sorting lemma and using it to prove correctness of columnsort.
>
> (See full problem statement in textbook for details of parts a-h and the columnsort algorithm description)

The 0-1 sorting lemma states that if an oblivious compare-exchange algorithm correctly sorts all input sequences consisting of only 0s and 1s, then it correctly sorts all inputs containing arbitrary values.

###  A. Proof that $$A[q] > A[p]$$, so $$B[p] = 0$$ and $$B[q] = 1$$

Since algorithm X fails to correctly sort array $$A$$, it puts $$A[q]$$ into the position where $$A[p]$$ should go, and $$A[p]$$ is the smallest value in the wrong location.

By definition of $$A[p]$$: all values smaller than $$A[p]$$ are placed correctly.
Since $$A[p]$$ should be placed before $$A[q]$$'s position, we have $$A[p] < A[q]$$.

Therefore $$A[q] > A[p]$$.

From the definition of array $$B$$:
- $$B[i] = 0$$ if $$A[i] \leq A[p]$$
- $$B[i] = 1$$ if $$A[i] > A[p]$$

Since $$A[p] \leq A[p]$$: $$B[p] = 0$$
Since $$A[q] > A[p]$$: $$B[q] = 1$$

### B. Proof that algorithm X fails to sort array $$B$$

We need to show that X puts $$B[q] = 1$$ into the position where $$B[p] = 0$$ should go.

Since X is oblivious, its sequence of compare-exchange operations depends only on the array size and indices, not on values.

Consider any compare-exchange operation $$\textsc{Compare-Exchange}(A, i, j)$$ in algorithm X.

**Claim:** If this operation exchanges $$A[i]$$ and $$A[j]$$, then it also exchanges $$B[i]$$ and $$B[j]$$.

**Proof of claim:** The operation exchanges if and only if $$A[i] > A[j]$$.

Case 1: $$A[i], A[j] \leq A[p]$$
Then $$B[i] = 0$$ and $$B[j] = 0$$, so $$B[i] \not> B[j]$$, no exchange for either.

Case 2: $$A[i] > A[p]$$ and $$A[j] \leq A[p]$$
Then $$B[i] = 1$$ and $$B[j] = 0$$, so $$B[i] > B[j]$$, exchange for both.

Case 3: $$A[i] \leq A[p]$$ and $$A[j] > A[p]$$
Then $$B[i] = 0$$ and $$B[j] = 1$$, so $$B[i] \not> B[j]$$, no exchange for either.

Case 4: $$A[i], A[j] > A[p]$$
Then $$B[i] = 1$$ and $$B[j] = 1$$.
If $$A[i] > A[j]$$, then both exchange.
If $$A[i] \leq A[j]$$, then neither exchanges.

In all cases, the compare-exchange behavior is the same for $$A$$ and $$B$$.

Since X performs the same sequence of operations on $$B$$ as on $$A$$, and $$B[p]$$ and $$B[q]$$ correspond to $$A[p]$$ and $$A[q]$$, algorithm X puts $$B[q] = 1$$ where $$B[p] = 0$$ should go.

Therefore, X fails to sort $$B$$.

{% include ads.html %}

### C. Columnsort as oblivious compare-exchange

Columnsort performs a fixed sequence of operations:
1. Sort each column (odd steps)
2. Fixed permutations (even steps)

Each "sort each column" operation can be implemented using a fixed sequence of compare-exchange operations (e.g., using any oblivious sorting network or algorithm applied independently to each column).

The permutation steps move elements to predetermined positions without comparisons.

Since all operations are predetermined by the array dimensions ($$r$$ and $$s$$) and don't depend on actual values, columnsort is an oblivious compare-exchange algorithm.

### D. After steps 1-3: at most $$s$$ dirty rows

An area is "clean" if it contains all 0s or all 1s. An area is "dirty" if it contains both.

After step 1, each column is sorted, so it might have clean rows of 0s at top, clean rows of 1s at bottom, and some dirty rows in between.

After step 2 (transpose and reshape), we rearrange the array but don't change the sorted property significantly.

After step 3 (sort each column again), each column is sorted.

The key insight: After step 3, consider the array read in column-major order. The 0s and 1s might not be perfectly separated, but the "dirty region" (where 0s and 1s mix) is limited.

Since we have $$s$$ columns and elements redistribute during transpose, at most $$s$$ rows can be dirty. The precise proof requires careful accounting of how elements move during the transpose and reshape operations.

{% include ads.html %}

### E. After step 4: dirty area of at most $$s^2$$ elements

Step 4 undoes the permutation from step 2, returning to the original shape.

After step 3, we had at most $$s$$ dirty rows (each row has $$s$$ elements), giving at most $$s \times s = s^2$$ dirty elements.

When we read in column-major order after step 4, these $$s^2$$ dirty elements form a contiguous dirty region in the middle, with clean regions of 0s before and clean regions of 1s after.

### F. Steps 5-8 produce sorted output

After step 5 (sort columns), step 6 (shift), step 7 (sort columns), and step 8 (unshift), the dirty region is further reduced and finally eliminated.

The shifting in step 6 helps redistribute elements so that after step 7, the dirty region is small enough that step 8 produces a fully sorted array.

The detailed proof involves showing that the $$s^2$$ dirty elements, after the shift and additional column sorts, are properly positioned such that the final unshift produces a sorted column-major ordering.

Since columnsort is oblivious and correctly sorts all 0-1 inputs, by the 0-1 sorting lemma, it correctly sorts all inputs with arbitrary values.

### G. When $$s$$ doesn't divide $$r$$: at most $$2s - 1$$ dirty rows

If $$s$$ doesn't divide $$r$$, the reshape in step 2 is more complex. Elements at row boundaries might split across multiple rows in the reshaped array.

This can create additional dirty rows, up to $$2s - 1$$ instead of $$s$$.

For columnsort to still work, we'd need $$r \geq 2(2s-1)^2 = 8s^2 - 8s + 2 \approx 8s^2$$.

### H. Simple change to allow $$s$$ not dividing $$r$$

Modify step 1: Instead of sorting each column fully, only sort the first $$\lfloor r/s \rfloor \cdot s$$ elements in each column (the part that divides evenly).

Alternatively: Pad the array with dummy elements to make $$r$$ divisible by $$s$$, then remove them at the end.

This ensures the reshape operations in steps 2 and 4 work cleanly without creating extra dirty rows.

{% capture note %}
Columnsort is an early example of a sorting network, a method of sorting using a fixed pattern of comparisons. While not practical for general use, sorting networks have applications in parallel computing and hardware sorting circuits.
{% endcapture %}
{% include aside.html title='Sorting Networks' %}
