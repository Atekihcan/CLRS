---
title:       Exercise 12.1-4
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "preorder tree walk, postorder tree walk, recursive algorithm"
description: "Give recursive algorithms that perform preorder and postorder tree walks in Θ(n) time on a tree of n nodes."
---

> Give recursive algorithms that perform preorder and postorder tree walks in $$\Theta(n)$$ time on a tree of $$n$$ nodes.

The three tree traversal orders differ only in when we visit (print) the root relative to its subtrees:
- **Preorder**: Root, then left subtree, then right subtree
- **Inorder**: Left subtree, then root, then right subtree
- **Postorder**: Left subtree, then right subtree, then root

### Preorder Tree Walk

In a preorder traversal, we visit the root before traversing its children. This is useful for creating a copy of the tree or evaluating prefix expressions.

{% capture code %}
PreorderTreeWalk(x)
    if x ≠ NIL
        print x.key
        PreorderTreeWalk(x.left)
        PreorderTreeWalk(x.right)
{% endcapture %}
{% include clrs_code.html title='PreorderTreeWalk(x)' %}

For example, on this tree:

```
      6
     / \
    3   8
   / \   \
  2   5   9
```

Preorder traversal prints: $$6, 3, 2, 5, 8, 9$$

{% include ads.html %}

### Postorder Tree Walk

In a postorder traversal, we visit the root after traversing its children. This is useful for deleting a tree (children must be deleted before parents) or evaluating postfix expressions.

{% capture code %}
PostorderTreeWalk(x)
    if x ≠ NIL
        PostorderTreeWalk(x.left)
        PostorderTreeWalk(x.right)
        print x.key
{% endcapture %}
{% include clrs_code.html title='PostorderTreeWalk(x)' %}

For the same tree above, postorder traversal prints: $$2, 5, 3, 9, 8, 6$$

### Time Complexity Analysis

Both algorithms run in $$\Theta(n)$$ time for an $$n$$-node tree. The proof is identical to Theorem 12.1 for inorder traversal:

Let $$T(n)$$ denote the time for an $$n$$-node subtree. For $$n > 0$$, if the left subtree has $$k$$ nodes and the right has $$n - k - 1$$ nodes:

$$\begin{align*}
T(n) &\le T(k) + T(n - k - 1) + d \\
&= (c+d)k + c + (c+d)(n-k-1) + c + d \\
&= (c+d)n + c
\end{align*}$$

where $$c$$ and $$d$$ are constants. The base case $$T(0) = c$$ holds, so $$T(n) = O(n)$$. Since we must visit all $$n$$ nodes, $$T(n) = \Omega(n)$$, giving us $$T(n) = \Theta(n)$$.

{% capture note %}
The three traversal orders have different applications:
- **Preorder**: Copying trees, serializing tree structure, prefix expression evaluation
- **Inorder**: Printing binary search tree keys in sorted order
- **Postorder**: Deleting trees, postfix expression evaluation, computing directory sizes

All three visit each node exactly once and run in linear time.
{% endcapture %}
{% include aside.html title='Applications of tree traversals' %}
