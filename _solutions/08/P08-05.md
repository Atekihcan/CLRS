---
title:       Problem 8-5
published:   2025-11-16 20:15
modified:    2025-11-16 20:15
keywords:    "k-sorted arrays, average sorting, partial sorting, heap, lower bound"
description: "Average sorting"
---

> **Average sorting**
>
> Suppose that, instead of sorting an array, we just require that the elements increase on average. More precisely, we call an $$n$$-element array $$A$$ **$$k$$-sorted** if, for all $$i = 1, 2, \ldots, n-k$$, the following holds:
>
> $$\frac{\sum_{j=i}^{i+k-1} A[j]}{k} \leq \frac{\sum_{j=i+1}^{i+k} A[j]}{k}$$
>
> 1. What does it mean for an array to be 1-sorted?
> 2. Give a permutation of the numbers 1, 2, ..., 10 that is 2-sorted, but not sorted.
> 3. Prove that an $$n$$-element array is $$k$$-sorted if and only if $$A[i] \leq A[i+k]$$ for all $$i = 1, 2, \ldots, n-k$$.
> 4. Give an algorithm that $$k$$-sorts an $$n$$-element array in $$O(n \lg(n/k))$$ time.
> 5. Show that we can sort a $$k$$-sorted array of length $$n$$ in $$O(n \lg k)$$ time. (Hint: Use the solution to Exercise 6.5-9.)
> 6. Show that when $$k$$ is a constant, $$k$$-sorting an $$n$$-element array requires $$\Omega(n \lg n)$$ time. (Hint: Use the solution to the previous part along with the lower bound on comparison sorts.)

### A. 1-sorted array

For $$k = 1$$, the condition becomes:

$$A[i] \leq A[i+1] \text{ for all } i = 1, 2, \ldots, n-1$$

This is just a sorted array! A 1-sorted array is a fully sorted array.

### B. 2-sorted but not sorted permutation

Consider: $$[1, 3, 2, 4, 6, 5, 7, 9, 8, 10]$$

Check 2-sorted condition ($$A[i] \leq A[i+2]$$):
- $$A[1] = 1 \leq A[3] = 2$$ ✓
- $$A[2] = 3 \leq A[4] = 4$$ ✓
- $$A[3] = 2 \leq A[5] = 6$$ ✓
- $$A[4] = 4 \leq A[6] = 5$$ ✓
- ... (all pairs satisfy the condition)

But it's not sorted since $$A[2] = 3 > A[3] = 2$$.

{% include ads.html %}

### C. Proof of equivalence

**Forward direction:** If $$A$$ is $$k$$-sorted, then $$A[i] \leq A[i+k]$$.

The $$k$$-sorted condition states:

$$\sum_{j=i}^{i+k-1} A[j] \leq \sum_{j=i+1}^{i+k} A[j]$$

Expanding both sides:

$$A[i] + \sum_{j=i+1}^{i+k-1} A[j] \leq \sum_{j=i+1}^{i+k-1} A[j] + A[i+k]$$

Subtracting the common middle terms:

$$A[i] \leq A[i+k]$$

**Reverse direction:** If $$A[i] \leq A[i+k]$$ for all $$i$$, then $$A$$ is $$k$$-sorted.

From $$A[i] \leq A[i+k]$$, we get:

$$A[i] + \sum_{j=i+1}^{i+k-1} A[j] \leq \sum_{j=i+1}^{i+k-1} A[j] + A[i+k]$$

which is the $$k$$-sorted condition.

### D. Algorithm to $$k$$-sort in $$O(n \lg(n/k))$$ time

Divide the array into $$k$$ interleaved subsequences:
- Subsequence 0: $$A[0], A[k], A[2k], \ldots$$
- Subsequence 1: $$A[1], A[k+1], A[2k+1], \ldots$$
- ...
- Subsequence $$k-1$$: $$A[k-1], A[2k-1], A[3k-1], \ldots$$

Each subsequence has approximately $$n/k$$ elements.

```python
def k_sort(A, n, k):
    # Sort each interleaved subsequence
    for i in range(k):
        # Extract subsequence i
        subseq = [A[j] for j in range(i, n, k)]

        # Sort it (using any O(m log m) sort)
        subseq.sort()

        # Put it back
        for idx, j in enumerate(range(i, n, k)):
            A[j] = subseq[idx]
```

Analysis:
- $$k$$ subsequences, each of size $$\approx n/k$$
- Sorting each takes $$O((n/k) \lg(n/k))$$
- Total: $$k \cdot O((n/k) \lg(n/k)) = O(n \lg(n/k))$$

This makes the array $$k$$-sorted because $$A[i]$$ and $$A[i+k]$$ are now in sorted order within their subsequence.

{% include ads.html %}

### E. Sorting a $$k$$-sorted array in $$O(n \lg k)$$ time

Use a min-heap of size $$k$$. The key observation from part (c) is that element $$A[i]$$ can only be displaced by at most $$k$$ positions from its final sorted position.

```python
def sort_k_sorted(A, n, k):
    import heapq
    result = []
    heap = []

    # Initialize heap with first k elements
    for i in range(min(k, n)):
        heapq.heappush(heap, A[i])

    # Process remaining elements
    for i in range(k, n):
        result.append(heapq.heappop(heap))
        heapq.heappush(heap, A[i])

    # Empty the heap
    while heap:
        result.append(heapq.heappop(heap))

    return result
```

Analysis:
- Heap operations: $$n$$ insertions and $$n$$ deletions
- Each operation takes $$O(\lg k)$$ time (heap size is at most $$k$$)
- Total: $$O(n \lg k)$$

### F. Lower bound of $$\Omega(n \lg n)$$ for constant $$k$$

Suppose we have a $$k$$-sorted array for constant $$k$$. From part (e), we can fully sort it in $$O(n \lg k) = O(n)$$ time (since $$k$$ is constant).

If we could $$k$$-sort in $$o(n \lg n)$$ time, we could:
1. $$k$$-sort in $$o(n \lg n)$$ time
2. Fully sort the $$k$$-sorted result in $$O(n)$$ time
3. Total: $$o(n \lg n) + O(n) = o(n \lg n)$$ time

But this contradicts the $$\Omega(n \lg n)$$ lower bound for comparison sorting!

Therefore, $$k$$-sorting requires $$\Omega(n \lg n)$$ time when $$k$$ is constant.
