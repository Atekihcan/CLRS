---
title:       Exercise 14.3-5
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "interval tree, exact match, search algorithm, logarithmic time"
description: "Suggest modifications to the interval-tree procedures to support the new operation INTERVAL-SEARCH-EXACTLY(T, i), where T is an interval tree and i is an interval. The operation should return a pointer to a node x in T such that x.int.low = i.low and x.int.high = i.high, or T.nil if T contains no such node. All operations, including INTERVAL-SEARCH-EXACTLY, should run in O(lg n) time on an n-node interval tree."
---

> Suggest modifications to the interval-tree procedures to support the new operation $$\textsc{Interval-Search-Exactly}(T, i)$$, where $$T$$ is an interval tree and $$i$$ is an interval. The operation should return a pointer to a node $$x$$ in $$T$$ such that $$x.int.low = i.low$$ and $$x.int.high = i.high$$, or $$T.nil$$ if $$T$$ contains no such node. All operations, including $$\textsc{Interval-Search-Exactly}$$, should run in $$O(\lg n)$$ time on an $$n$$-node interval tree.

Since interval trees are red-black trees keyed by the $$low$$ endpoint, we can search for an interval with a specific $$low$$ value in $$O(\lg n)$$ time using binary search. Once we find a node with the matching $$low$$ endpoint, we need to check if its $$high$$ endpoint also matches.

However, there might be multiple intervals with the same $$low$$ endpoint. We need to handle this case.

### No Modification Needed

The standard interval tree already supports this operation without any modifications. We just need to search for the $$low$$ endpoint and then check if the $$high$$ endpoint matches.

{% capture code %}
Interval-Search-Exactly(T, i)
    x = T.root
    while x != T.nil
        if i.low == x.int.low and i.high == x.int.high
            return x
        elseif i.low < x.int.low
            x = x.left
        else
            x = x.right
    return T.nil
{% endcapture %}
{% include clrs_code.html title="Interval-Search-Exactly(T, i)" %}

{% include ads.html %}

This works if intervals are allowed to be duplicate (same $$low$$ and $$high$$) or if intervals with the same $$low$$ can have different $$high$$ values but we store them in a way that allows binary search on both coordinates.

However, there's a problem: if multiple intervals have the same $$low$$ endpoint, the binary search tree property only orders by $$low$$, not by $$high$$. So we might miss the matching interval.

### Modified Approach with Secondary Key

To handle multiple intervals with the same $$low$$ endpoint, we can modify the tree to use $$(low, high)$$ as a compound key with lexicographic ordering: first compare $$low$$, then compare $$high$$ if $$low$$ values are equal.

Modify the tree operations:
- **Insertion:** When comparing intervals, use: if $$i_1.low < i_2.low$$, or if $$i_1.low = i_2.low$$ and $$i_1.high < i_2.high$$
- **Search:** Use the same comparison to navigate the tree

With this modification, $$\textsc{Interval-Search-Exactly}$$ becomes a standard BST search:

{% capture code %}
Interval-Search-Exactly(T, i)
    x = T.root
    while x != T.nil and not (x.int.low == i.low and x.int.high == i.high)
        if i.low < x.int.low or (i.low == x.int.low and i.high < x.int.high)
            x = x.left
        else
            x = x.right
    return x
{% endcapture %}
{% include clrs_code.html title="Interval-Search-Exactly(T, i)" %}

### Impact on Other Operations

The lexicographic ordering doesn't affect the asymptotic complexity of other operations:
- **Insertion/Deletion:** Still $$O(\lg n)$$ (just using a different comparison function)
- **Interval-Search:** Still $$O(\lg n)$$ (the algorithm logic remains the same, only the comparison for navigating the tree changes)

The $$max$$ attribute maintenance remains unchanged because it doesn't depend on how we order intervals with the same $$low$$ endpoint.

All operations continue to run in $$O(\lg n)$$ time on an $$n$$-node interval tree.
