---
title:       Exercise 10.2-1
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "singly linked list, insert, delete, dynamic sets"
description: "Can you implement the dynamic-set operation INSERT on a singly linked list in O(1) time? How about DELETE?"
---

> Can you implement the dynamic-set operation $$\textsc{Insert}$$ on a singly linked list in $$O(1)$$ time? How about $$\textsc{Delete}$$?

For a singly linked list, each node has a $$\textit{next}$$ pointer but no $$\textit{prev}$$ pointer (unlike a doubly linked list).

### INSERT

Yes, we can implement $$\textsc{Insert}$$ in $$O(1)$$ time. The trick is to insert at the head of the list, just like we do with doubly linked lists. We create a new node, point its $$\textit{next}$$ to the current head, and update the list's head pointer to the new node.

{% capture code %}
LIST-INSERT(L, x)
    x.next = L.head
    L.head = x
{% endcapture %}
{% include clrs_code.html %}

This takes constant time regardless of the list length.

### DELETE

No, we cannot implement $$\textsc{Delete}$$ in $$O(1)$$ time for a general singly linked list. The problem is that to delete a node $$x$$, we need to update the $$\textit{next}$$ pointer of $$x$$'s predecessor to point to $$x$$'s successor. But in a singly linked list, we have no direct way to find $$x$$'s predecessor.

Given a pointer to node $$x$$, we must traverse the list from the head until we find the node whose $$\textit{next}$$ pointer points to $$x$$. This takes $$O(n)$$ time in the worst case.

{% capture code %}
LIST-DELETE(L, x)
    if L.head == x
        L.head = x.next
    else
        // Find predecessor of x
        prev = L.head
        while prev.next != x
            prev = prev.next
        prev.next = x.next
{% endcapture %}
{% include clrs_code.html %}

{% capture note %}
There's a clever trick for deletion if we're allowed to modify the data: we can copy the data from $$x.\textit{next}$$ into $$x$$, then delete $$x.\textit{next}$$ instead. This works in $$O(1)$$ time:

```
x.key = x.next.key
x.next = x.next.next
```

However, this doesn't work if $$x$$ is the last node in the list (since there's no next node to copy from), and it may not be appropriate if other parts of the program hold pointers to specific nodes (since we've changed which node contains which data).
{% endcapture %}
{% include aside.html title='A Deletion Trick' %}
