---
title:       Exercise 9.2-3
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "randomized select, iterative algorithm, order statistics, tail recursion"
description: "Write an iterative version of RANDOMIZED-SELECT."
---

> Write an iterative version of $$\textsc{Randomized-Select}$$.

The recursive version of $$\textsc{Randomized-Select}$$ is tail-recursive, meaning the recursive call is the last operation performed. This makes it straightforward to convert to an iterative version using a loop.

{% capture code %}
Iterative-Randomized-Select(A, p, r, i)
    while p < r
        q = Randomized-Partition(A, p, r)
        k = q - p + 1
        if i == k
            return A[q]
        elseif i < k
            r = q - 1
        else
            p = q + 1
            i = i - k
    return A[p]
{% endcapture %}
{% include clrs_code.html %}

The algorithm maintains the invariant that the $$i$$th smallest element of the original array is the $$i$$th smallest element of the current subarray $$A[p \ldots r]$$. In each iteration, we partition around a random pivot and adjust the search space:

If the pivot is the $$i$$th smallest ($$i = k$$), we return it immediately. If the $$i$$th smallest is in the low partition ($$i < k$$), we narrow our search to $$A[p \ldots q-1]$$ keeping $$i$$ unchanged. If it's in the high partition ($$i > k$$), we narrow our search to $$A[q+1 \ldots r]$$ and adjust $$i$$ to $$i - k$$ because we've eliminated $$k$$ smaller elements.

The loop terminates when $$p = r$$, at which point the subarray contains a single element that must be the answer.

The iterative version has the same expected running time of $$O(n)$$ as the recursive version, but uses $$O(1)$$ space instead of $$O(\log n)$$ expected space for the recursion stack.