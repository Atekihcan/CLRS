---
title:       Exercise 10.3-3
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "allocate object, free object, prev attribute, memory management"
description: "Why don't we need to set or reset the prev attributes of objects in the implementation of the ALLOCATE-OBJECT and FREE-OBJECT procedures?"
---

> Why don't we need to set or reset the $$\textit{prev}$$ attributes of objects in the implementation of the $$\textsc{Allocate-Object}$$ and $$\textsc{Free-Object}$$ procedures?

The free list is implemented as a singly linked list, not a doubly linked list. It only uses the $$\textit{next}$$ attribute to link free objects together, forming a chain. The $$\textit{prev}$$ attribute is not used in the free list structure at all.

When we allocate an object, it gets removed from the free list and will be inserted into an actual doubly linked list by a higher-level procedure (like $$\textsc{List-Insert}$$). That higher-level procedure is responsible for setting all the appropriate attributes, including $$\textit{prev}$$, when it inserts the object into the list.

Similarly, when we free an object, we're removing it from whatever doubly linked list it was in (if any) and adding it to the free list. The higher-level procedure that calls $$\textsc{Free-Object}$$ has already updated the $$\textit{prev}$$ and $$\textit{next}$$ pointers of neighboring nodes to remove the object from its original list. Once the object is on the free list, its $$\textit{prev}$$ value is irrelevant because the free list only uses $$\textit{next}$$ pointers.

In summary:
- The free list is singly linked (uses only $$\textit{next}$$)
- $$\textsc{Allocate-Object}$$ doesn't set $$\textit{prev}$$ because the calling procedure will set it appropriately
- $$\textsc{Free-Object}$$ doesn't reset $$\textit{prev}$$ because it's not used in the free list

This design keeps $$\textsc{Allocate-Object}$$ and $$\textsc{Free-Object}$$ simple and fast ($$O(1)$$ time), while leaving the responsibility for maintaining doubly linked list structure to the higher-level operations that actually use those lists.

{% capture note %}
This separation of concerns is good design. The allocation procedures only manage memory (which objects are available for use), while list manipulation procedures (like $$\textsc{List-Insert}$$ and $$\textsc{List-Delete}$$) handle the logical structure of the data. Each procedure does one thing well.
{% endcapture %}
{% include aside.html title='Separation of Concerns' %}
