---
title:       Exercise 14.3-3
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "interval tree, minimum low endpoint, search algorithm, logarithmic time"
description: "Describe an efficient algorithm that, given an interval i, returns an interval overlapping i that has the minimum low endpoint, or T.nil if no such interval exists."
---

> Describe an efficient algorithm that, given an interval $$i$$, returns an interval overlapping $$i$$ that has the minimum low endpoint, or $$T.nil$$ if no such interval exists.

Among all intervals that overlap $$i$$, we want the one with the smallest $$low$$ endpoint. Since the interval tree is keyed by low endpoints, we essentially want to find the leftmost (in inorder traversal) interval that overlaps $$i$$.

The strategy is to search for overlapping intervals but always prefer going left when possible, as nodes with smaller keys are in the left subtree.

{% capture code %}
Interval-Search-Min-Low(T, i)
    x = T.root
    result = T.nil

    while x != T.nil
        if i overlaps x.int
            // Found an overlapping interval
            result = x
            // Check if there's one with even smaller low in left subtree
            if x.left != T.nil and x.left.max >= i.low
                x = x.left
            else
                break  // Can't find anything better
        elseif x.left != T.nil and x.left.max >= i.low
            x = x.left
        else
            x = x.right

    return result
{% endcapture %}
{% include clrs_code.html title="Interval-Search-Min-Low(T, i)" %}

{% include ads.html %}

### How It Works

The algorithm maintains a variable $$result$$ that stores the best candidate found so far. We traverse the tree, and whenever we find an overlapping interval:

1. Update $$result$$ to the current node $$x$$
2. Check if the left subtree might contain an overlapping interval with smaller $$low$$
3. If yes ($$x.left.max \geq i.low$$), continue searching left
4. Otherwise, we've found the minimum and can stop

The key insight is that once we find an overlapping interval, we only need to check the left subtree for potentially better candidates. We never need to check the right subtree because all intervals there have larger $$low$$ endpoints than the current node.

When we don't find an overlap at the current node, we use the same logic as $$\textsc{Interval-Search}$$: go left if the left subtree might contain an overlapping interval, otherwise go right.

### Time Complexity

The algorithm traverses at most one path from root to leaf, plus potentially some additional nodes in left subtrees when updating the result. However, each time we update $$result$$ and go left, we're descending the tree, so we still traverse $$O(\lg n)$$ nodes total.

The time complexity is $$O(\lg n)$$ for an $$n$$-node interval tree.

### Example

Given intervals $$[5, 10]$$, $$[2, 8]$$, $$[7, 12]$$, and $$[3, 6]$$, searching for an interval overlapping $$i = [6, 9]$$:
- All four intervals overlap $$i$$
- The one with minimum $$low$$ is $$[2, 8]$$ with $$low = 2$$
- The algorithm would find this by searching left whenever possible among overlapping intervals
