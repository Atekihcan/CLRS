---
title:       Exercise 14.1-6
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "order-statistic tree, rank attribute, tree maintenance, rotations"
description: "Observe that whenever we reference the size attribute of a node in either OS-SELECT or OS-RANK, we use it only to compute a rank. Accordingly, suppose we store in each node its rank in the subtree of which it is the root. Show how to maintain this information during insertion and deletion."
---

> Observe that whenever we reference the size attribute of a node in either $$\textsc{OS-Select}$$ or $$\textsc{OS-Rank}$$, we use it only to compute a rank. Accordingly, suppose we store in each node its rank in the subtree of which it is the root. Show how to maintain this information during insertion and deletion. (Remember that these two operations can cause rotations.)

While storing rank instead of size seems natural since we always compute rank from size, maintaining rank attributes during tree modifications is actually more expensive than maintaining size attributes.

Define $$x.rank$$ as the rank of node $$x$$ within the subtree rooted at $$x$$. This equals $$x.left.size + 1$$ in the size-based representation. Let's examine how to maintain this during insertion, deletion, and rotations.

### Insertion

During insertion, when we add a new node as a leaf, we must update the rank of all ancestors where the new node falls in their left subtree. If we insert a node as the left child of some node $$y$$ (or within $$y$$'s left subtree), then $$y.rank$$ must be incremented by 1, as must the ranks of all ancestors of $$y$$ for which $$y$$ is in their left subtree.

This requires walking up from the inserted node to the root, updating ranks along the way. At each node $$z$$ on this path, if the insertion was in $$z$$'s left subtree, we increment $$z.rank$$. This takes $$O(\lg n)$$ time.

### Deletion

Deletion is symmetric to insertion. When we remove a node, we must decrement the rank of all ancestors for which the deleted node was in their left subtree. This also takes $$O(\lg n)$$ time.

### Rotations

Rotations present the main challenge. Consider a left rotation on node $$x$$ with right child $$y$$. Before the rotation, $$x.rank = x.left.size + 1$$. After the rotation, $$x$$ becomes the left child of $$y$$, so $$x$$'s new rank in its subtree is just $$x.left.size + 1$$ (unchanged, since $$x$$'s left subtree is unchanged).

However, $$y$$'s rank changes. Before rotation, $$y.rank = y.left.size + 1$$. After rotation, $$y$$'s left subtree includes the entire subtree that was rooted at $$x$$, so $$y.rank = x.rank + y.left.size + 1$$.

The update formulas for a left rotation are:

$$\begin{align*}
y.rank' &= x.rank + y.rank \\
x.rank' &= x.rank \text{ (unchanged)}
\end{align*}$$

Right rotation is symmetric. Thus, rotations can be handled in $$O(1)$$ time.

### Conclusion

While rank attributes can be maintained, they offer no advantage over size attributes. Both approaches have the same asymptotic complexity: $$O(\lg n)$$ for insertion and deletion, with $$O(1)$$ updates per rotation. The size attribute is preferable because it has a simpler interpretation (number of nodes in subtree) and simpler update rules during insertion and deletion.
