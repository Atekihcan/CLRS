---
title:       Problem 14-2
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "Josephus problem, order-statistic tree, circular list, permutation"
description: "We define the Josephus problem as follows. Suppose that n people form a circle and that we are given a positive integer m ≤ n. Beginning with a designated first person, we proceed around the circle, removing every mth person. The order in which people are removed defines the (n,m)-Josephus permutation."
---

> **14-2 Josephus permutation**
>
> We define the Josephus problem as follows. Suppose that $$n$$ people form a circle and that we are given a positive integer $$m \leq n$$. Beginning with a designated first person, we proceed around the circle, removing every $$m$$th person. After each person is removed, counting continues around the circle that remains. This process continues until we have removed all $$n$$ people. The order in which the people are removed from the circle defines the $$(n, m)$$-Josephus permutation of the integers $$1, 2, \ldots, n$$. For example, the $$(7, 3)$$-Josephus permutation is $$\langle 3, 6, 2, 7, 5, 1, 4 \rangle$$.
>
> 1. Suppose that $$m$$ is a constant. Describe an $$O(n)$$-time algorithm that, given an integer $$n$$, outputs the $$(n, m)$$-Josephus permutation.
> 2. Suppose that $$m$$ is not a constant. Describe an $$O(n \lg n)$$-time algorithm that, given integers $$n$$ and $$m$$, outputs the $$(n, m)$$-Josephus permutation.

### A.

When $$m$$ is constant, we can use a circular linked list and simulate the process directly.

{% capture code %}
Josephus-Constant-M(n, m)
    // Create circular linked list of 1, 2, ..., n
    create circular linked list L with elements 1 to n
    current = L.head
    result = empty array

    while L is not empty
        // Count m-1 steps (current is position 1)
        for i = 1 to m - 1
            current = current.next
        // Remove current person
        append current.value to result
        next_person = current.next
        remove current from L
        current = next_person

    return result
{% endcapture %}
{% include clrs_code.html title="Josephus-Constant-M(n, m)" %}

Each iteration removes one person and performs $$O(m)$$ steps to find the next person to remove. Since $$m$$ is constant, each iteration takes $$O(1)$$ time. With $$n$$ iterations, the total time is $$O(n)$$.

For example, with $$(7, 3)$$:
- Start at 1, count 3: remove 3
- Continue from 4, count 3: remove 6
- Continue from 7, count 3 (wrapping): remove 2
- And so on...

The circular linked list allows constant-time wraparound and deletion.

{% include ads.html %}

### B.

When $$m$$ is not constant, stepping through $$m$$ positions each time could take $$\Theta(n)$$ time per iteration, giving $$\Theta(n^2)$$ total time. We can do better using an order-statistic tree.

The key insight: instead of explicitly simulating the circular list, we use an order-statistic tree to represent the remaining people by their positions in the circle. When we need to find the $$m$$th person, we use $$\textsc{OS-Select}$$.

{% capture code %}
Josephus-Variable-M(n, m)
    // Initialize order-statistic tree with 1, 2, ..., n
    T = empty order-statistic tree
    for i = 1 to n
        Insert(T, i)

    result = empty array
    pos = 1  // current position in the circle (1-indexed)

    while T.root.size > 0
        // Calculate position of next person to remove
        // We're at position pos, need to go m steps
        pos = ((pos + m - 2) mod T.root.size) + 1

        // Find and remove the person at this position
        x = OS-Select(T.root, pos)
        append x.key to result
        Delete(T, x)

        // If we deleted the last person in the tree, reset doesn't matter
        // Otherwise, pos is now the position after the deleted person
        // (no need to increment because deletion shifts everyone down)

    return result
{% endcapture %}
{% include clrs_code.html title="Josephus-Variable-M(n, m)" %}

Let me explain the position calculation. If we're currently at position $$pos$$ and need to count $$m$$ people (including the current position as 1), the next person to remove is at position $$(pos + m - 1)$$ in the circular list. However, we need to wrap around using modulo. After removing someone, the positions of all subsequent people decrease by 1.

More carefully:
- Current position in tree: $$pos$$
- Count $$m$$ steps forward: $$pos + m - 1$$
- Wrap around circle of size $$s = T.root.size$$: $$((pos + m - 2) \mod s) + 1$$

Here's why: we want $$(pos + m - 1)$$ but using 0-indexed modulo arithmetic it's $$(pos - 1 + m - 1) \mod s = (pos + m - 2) \mod s$$, then convert back to 1-indexed by adding 1.

Each iteration performs:
- One $$\textsc{OS-Select}$$: $$O(\lg n)$$
- One $$\textsc{Delete}$$: $$O(\lg n)$$
- Constant-time arithmetic

With $$n$$ iterations, total time is $$O(n \lg n)$$.

### Verification with Example

For $$(7, 3)$$:
- $$T = \{1,2,3,4,5,6,7\}$$, $$pos = 1$$
- Next: $$((1 + 3 - 2) \mod 7) + 1 = 3$$, remove person 3 → $$T = \{1,2,4,5,6,7\}$$
- Next: $$((3 + 3 - 2) \mod 6) + 1 = 5$$, remove person 6 (5th in remaining) → $$T = \{1,2,4,5,7\}$$
- Continue...

The algorithm correctly generates the Josephus permutation in $$O(n \lg n)$$ time.
