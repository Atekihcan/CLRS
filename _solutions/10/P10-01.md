---
title:       Problem 10-1
published:   2025-11-16 12:00
modified:    2025-11-16 12:00
keywords:    "linked lists, dynamic sets, running time comparison"
description: "For each of the four types of lists in the following table, what is the asymptotic worst-case running time for each dynamic-set operation listed?"
---

> For each of the four types of lists in the following table, what is the asymptotic worst-case running time for each dynamic-set operation listed?

We need to analyze the running time of seven dynamic-set operations on four different list types: unsorted singly linked, sorted singly linked, unsorted doubly linked, and sorted doubly linked lists.

| Operation | Unsorted<br/>Singly Linked | Sorted<br/>Singly Linked | Unsorted<br/>Doubly Linked | Sorted<br/>Doubly Linked |
|-----------|------------|--------|------------|--------|
| $$\textsc{Search}(L, k)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ |
| $$\textsc{Insert}(L, x)$$ | $$O(1)$$ | $$\Theta(n)$$ | $$O(1)$$ | $$\Theta(n)$$ |
| $$\textsc{Delete}(L, x)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ | $$O(1)$$ | $$O(1)$$ |
| $$\textsc{Successor}(L, x)$$ | $$\Theta(n)$$ | $$O(1)$$ | $$\Theta(n)$$ | $$O(1)$$ |
| $$\textsc{Predecessor}(L, x)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ | $$O(1)$$ |
| $$\textsc{Minimum}(L)$$ | $$\Theta(n)$$ | $$O(1)$$ | $$\Theta(n)$$ | $$O(1)$$ |
| $$\textsc{Maximum}(L)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ | $$\Theta(n)$$ | $$O(1)$$ |

{% include ads.html %}

### Explanation

**$$\textsc{Search}(L, k)$$:** All list types require $$\Theta(n)$$ time in the worst case because we may need to examine every element. Even in a sorted list, we can't use binary search without random access, so we must traverse linearly.

**$$\textsc{Insert}(L, x)$$:**
- **Unsorted lists:** $$O(1)$$ because we can insert at the head without checking position.
- **Sorted lists:** $$\Theta(n)$$ because we must find the correct position to maintain sorted order.

**$$\textsc{Delete}(L, x)$$:**
- **Singly linked:** $$\Theta(n)$$ because we must find the predecessor (which requires traversing from the head).
- **Doubly linked:** $$O(1)$$ because we can directly access both neighbors and update their pointers.

**$$\textsc{Successor}(L, x)$$:**
- **Unsorted lists:** $$\Theta(n)$$ because we must search the entire list to find the next larger element.
- **Sorted lists:** $$O(1)$$ because the successor is simply the next element ($$x.\textit{next}$$).

**$$\textsc{Predecessor}(L, x)$$:**
- **Unsorted lists:** $$\Theta(n)$$ because we must search the entire list.
- **Sorted, singly linked:** $$\Theta(n)$$ because we must traverse from the head to find the previous element.
- **Sorted, doubly linked:** $$O(1)$$ because the predecessor is simply $$x.\textit{prev}$$.

**$$\textsc{Minimum}(L)$$:**
- **Unsorted lists:** $$\Theta(n)$$ because we must examine all elements.
- **Sorted lists:** $$O(1)$$ because the minimum is at the head ($$L.\textit{head}$$).

**$$\textsc{Maximum}(L)$$:**
- **Unsorted lists:** $$\Theta(n)$$ because we must examine all elements.
- **Sorted, singly linked:** $$\Theta(n)$$ because we must traverse to the tail.
- **Sorted, doubly linked:** $$O(1)$$ if we maintain a tail pointer; otherwise $$\Theta(n)$$. Assuming we maintain a tail pointer, it's $$O(1)$$.

{% capture note %}
The table shows clear trade-offs:
- **Doubly linked vs. singly linked:** The extra $$\textit{prev}$$ pointer in doubly linked lists enables $$O(1)$$ deletion and predecessor operations (in sorted lists).
- **Sorted vs. unsorted:** Maintaining sorted order costs time during insertion but enables fast minimum, maximum, and successor operations.
- The best choice depends on which operations are most frequent in your application.
{% endcapture %}
{% include aside.html title='Choosing the Right List Type' %}
