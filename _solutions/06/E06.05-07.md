---
title:       Exercise 6.5-7
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "priority queue, FIFO queue, stack, data structure implementation"
description: "Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with a priority queue."
---

> Show how to implement a first-in, first-out queue with a priority queue. Show how to implement a stack with a priority queue. (Queues and stacks are defined in Section 10.1.)

The key to using a priority queue to simulate other data structures is to assign priorities that enforce the desired ordering. For a queue (first-in, first-out or FIFO), we want the oldest element to have highest priority. For a stack (last-in, first-out or LIFO), we want the newest element to have highest priority.

A queue works like people waiting at a ticket counter. You join the line at the back. You get served at the front.

A stack works like a vertical pile of plates in a cafeteria dispenser. You only touch the top plate. Last plate added is the first plate removed.

### Implementing a FIFO Queue

A FIFO queue processes elements in the order they arrive. We can simulate this using a min-priority queue by assigning increasing priorities to elements as they arrive.

Using a min-priority queue:

{% capture code %}
priority = priority + 1
Min-Heap-Insert(Q, x, priority)
{% endcapture %}
{% include clrs_code.html title="Enqueue(Q, x)" %}

{% capture code %}
return Heap-Extract-Min(Q)
{% endcapture %}
{% include clrs_code.html title="Dequeue(Q)" %}

The element with the smallest priority (earliest arrival) has highest priority in the min-heap and is extracted first, giving FIFO behavior.

{% include ads.html %}

### Implementing a Stack

A LIFO stack processes the most recently added element first. We can simulate this using a max-priority queue by assigning increasing priorities to elements as they arrive.

Using a max-priority queue:

{% capture code %}
priority = priority + 1
Max-Heap-Insert(S, x, priority)
{% endcapture %}
{% include clrs_code.html title="Push(S, x)" %}

{% capture code %}
return Heap-Extract-Max(S)
{% endcapture %}
{% include clrs_code.html title="Pop(S)" %}

The element with the largest priority (most recent arrival) has highest priority in the max-heap and is extracted first, giving LIFO behavior.

### Analysis

Both implementations support all operations in $$O(\lg n)$$ time, where $$n$$ is the number of elements currently in the structure. This is slower than optimal queue and stack implementations (which achieve $$O(1)$$ for all operations using arrays or linked lists), but it demonstrates the versatility of priority queues. Priority queues are most valuable when elements truly have varying importance, not just temporal ordering.

### Python Implementation

The following interactive demonstration implements both data structures from scratch. We build complete `MinHeap` and `MaxHeap` classes with insert and extract operations, then use these to implement the queue and stack.

{% include code/code.html file='code/06/code_E060507.py' %}
