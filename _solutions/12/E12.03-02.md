---
title:       Exercise 12.3-2
published:   2025-11-16 10:00
modified:    2025-11-16 10:00
keywords:    "binary search tree, tree insertion, tree search, node examination"
description: "Suppose that we construct a binary search tree by repeatedly inserting distinct values into the tree. Argue that the number of nodes examined in searching for a value in the tree is one plus the number of nodes examined when the value was first inserted into the tree."
---

> Suppose that we construct a binary search tree by repeatedly inserting distinct values into the tree. Argue that the number of nodes examined in searching for a value in the tree is one plus the number of nodes examined when the value was first inserted into the tree.

This relationship holds because insertion and search follow the same path through the tree, with insertion examining one additional node (the $$\textsc{Nil}$$ position where the new node is placed).

### Argument

When we insert a value $$v$$ into a binary search tree $$T$$, the $$\textsc{Tree-Insert}$$ algorithm:

1. Starts at the root
2. Compares $$v$$ with each node along a path, going left or right based on the comparison
3. Continues until it finds a $$\textsc{Nil}$$ position (where $$x = \textsc{Nil}$$ in the iterative version)
4. Inserts the new node at that $$\textsc{Nil}$$ position

Let us say $$\textsc{Tree-Insert}$$ examines nodes $$x_1, x_2, \ldots, x_k, \textsc{Nil}$$ where:
- $$x_1$$ is the root
- $$x_k$$ is the parent of the newly inserted node
- The final "examination" is checking that the next position is $$\textsc{Nil}$$

So $$\textsc{Tree-Insert}$$ examines $$k$$ actual nodes plus one $$\textsc{Nil}$$ position, for a total of $$k + 1$$ examinations.

Later, when we search for the same value $$v$$ using $$\textsc{Tree-Search}$$:

1. Starts at the root ($$x_1$$)
2. Follows the exact same path: $$x_1, x_2, \ldots, x_k$$, and then the node that was inserted
3. Finds $$v$$ at the node that was inserted (let us call it $$x_{k+1}$$)

So $$\textsc{Tree-Search}$$ examines $$k + 1$$ nodes: $$x_1, x_2, \ldots, x_k, x_{k+1}$$.

### Why the paths are the same

The key insight is that **inserting $$v$$ does not change the search path to any value that is already in the tree**, and **searching for $$v$$ follows the same comparisons that were made during insertion**.

When we inserted $$v$$:
- At each node $$x_i$$ (for $$i = 1, \ldots, k$$), we compared $$v$$ with $$x_i.\textit{key}$$ and went left or right
- These comparisons are identical to those made during search
- The only difference: insertion examines the $$\textsc{Nil}$$ position, while search examines the inserted node itself

### Formal relationship

Let $$n_{\text{insert}}$$ = number of nodes examined during insertion (including the $$\textsc{Nil}$$ check)
Let $$n_{\text{search}}$$ = number of nodes examined during search

{% include ads.html %}

Then: $$n_{\text{search}} = n_{\text{insert}}$$

Wait, let me reconsider. The problem says "one plus the number of nodes examined when the value was first inserted." Let us recount:

If we count **actual nodes** (not $$\textsc{Nil}$$):
- Insertion examines $$k$$ actual nodes before inserting
- Search examines $$k + 1$$ nodes (the $$k$$ nodes on the path, plus the target node)

So: $$n_{\text{search}} = n_{\text{insert}} + 1$$

This is correct! ✓

### Example

Insert 13 into this tree:

```
        12
       /  \
      5   18
     / \  /  \
    2   9 15  19
```

Insertion of 13:
- Examine 12: $$13 > 12$$, go right
- Examine 18: $$13 < 18$$, go left
- Examine 15: $$13 < 15$$, go left
- Reach $$\textsc{Nil}$$, insert 13

**Nodes examined during insertion:** 3 (nodes 12, 18, 15)

Search for 13:
- Examine 12: $$13 > 12$$, go right
- Examine 18: $$13 < 18$$, go left
- Examine 15: $$13 < 15$$, go left
- Examine 13: Found!

**Nodes examined during search:** 4 (nodes 12, 18, 15, 13)

Indeed, $$4 = 3 + 1$$ ✓

{% capture note %}
This property makes intuitive sense: searching for a value finds it one level deeper than where insertion placed it, because insertion stops at the parent of the new node, while search continues to the new node itself.

This relationship is useful for analyzing the performance of operations on BSTs: if we know the cost of insertion, we can immediately determine the cost of searching for that same value.
{% endcapture %}
{% include aside.html title='Search cost from insertion cost' %}
