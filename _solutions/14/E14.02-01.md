---
title:       Exercise 14.2-1
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "augmented data structure, order-statistic tree, pointers, successor, predecessor"
description: "Show, by adding pointers to the nodes, how to support each of the dynamic-set queries MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR in O(1) worst-case time on an augmented order-statistic tree. The asymptotic performance of other operations on order-statistic trees should not be affected."
---

> Show, by adding pointers to the nodes, how to support each of the dynamic-set queries $$\textsc{Minimum}$$, $$\textsc{Maximum}$$, $$\textsc{Successor}$$, and $$\textsc{Predecessor}$$ in $$O(1)$$ worst-case time on an augmented order-statistic tree. The asymptotic performance of other operations on order-statistic trees should not be affected.

We can add four pointers to the tree structure (not to each node) to achieve $$O(1)$$ queries: $$T.min$$, $$T.max$$, and threading pointers $$x.succ$$ and $$x.pred$$ in each node.

### Augmentation

Add to the tree structure:
- $$T.min$$: pointer to the minimum element
- $$T.max$$: pointer to the maximum element

Add to each node $$x$$:
- $$x.succ$$: pointer to the successor of $$x$$
- $$x.pred$$: pointer to the predecessor of $$x$$

These create a doubly-linked list threading through the tree in sorted order, plus direct pointers to the endpoints.

### Queries

All four queries now take $$O(1)$$ time:
- $$\textsc{Minimum}(T)$$: return $$T.min$$
- $$\textsc{Maximum}(T)$$: return $$T.max$$
- $$\textsc{Successor}(T, x)$$: return $$x.succ$$
- $$\textsc{Predecessor}(T, x)$$: return $$x.pred$$

{% include ads.html %}

### Maintenance During Insertion

When inserting a new node $$z$$:

1. After determining where $$z$$ should be inserted using normal BST insertion, find $$z$$'s predecessor $$y$$ and successor $$w$$ in the tree (before $$z$$ is inserted)
2. Set $$z.pred = y$$ and $$z.succ = w$$
3. If $$y \neq T.nil$$, set $$y.succ = z$$; otherwise set $$T.min = z$$
4. If $$w \neq T.nil$$, set $$w.pred = z$$; otherwise set $$T.max = z$$

Finding the predecessor and successor can be done in $$O(\lg n)$$ time during the insertion process. As we traverse down to find the insertion point, the last node where we went right is the predecessor, and the last node where we went left is the successor.

### Maintenance During Deletion

When deleting node $$z$$:

1. Let $$y = z.pred$$ and $$w = z.succ$$
2. If $$y \neq T.nil$$, set $$y.succ = w$$; otherwise set $$T.min = w$$
3. If $$w \neq T.nil$$, set $$w.pred = y$$; otherwise set $$T.max = y$$

This takes $$O(1)$$ time.

### Maintenance During Rotations

Rotations don't change the inorder traversal of the tree, so they don't affect the successor and predecessor pointers. No updates are needed.

### Conclusion

By adding $$O(n)$$ extra space for the threading pointers and $$O(1)$$ space for min/max pointers, we achieve $$O(1)$$ queries while maintaining $$O(\lg n)$$ insertion and deletion times. The additional pointer updates during insertion are absorbed into the $$O(\lg n)$$ insertion time, and deletion pointer updates take $$O(1)$$ time.
