---
title:       Problem 14-1
published:   2025-11-16 00:00
modified:    2025-11-16 00:00
keywords:    "interval tree, maximum overlap point, augmented data structure"
description: "Suppose that we wish to keep track of a point of maximum overlap in a set of intervals—a point with the largest number of intervals in the set that overlap it."
---

> **14-1 Point of maximum overlap**
>
> Suppose that we wish to keep track of a point of maximum overlap in a set of intervals—a point with the largest number of intervals in the set that overlap it.
>
> 1. Show that there will always be a point of maximum overlap that is an endpoint of one of the segments.
> 2. Design a data structure that efficiently supports the operations $$\textsc{Interval-Insert}$$, $$\textsc{Interval-Delete}$$, and $$\textsc{Find-POM}$$, which returns a point of maximum overlap. (Hint: Keep a red-black tree of all the endpoints. Associate a value of $$+1$$ with each left endpoint, and associate a value of $$-1$$ with each right endpoint. Augment each node of the tree with some extra information to maintain the point of maximum overlap.)

### A.

Think of walking along the real line from left to right. As we cross the left endpoint of an interval, one more interval is now overlapping our current position. As we cross the right endpoint, one fewer interval overlaps. The number of overlapping intervals only changes at endpoints.

Suppose the maximum overlap count is $$k$$, achieved at some point $$p$$ that is not an endpoint. Since overlap counts only change at endpoints, and $$p$$ is not an endpoint, the entire interval containing $$p$$ between two consecutive endpoints must have the same overlap count $$k$$. Therefore, the left endpoint of this interval (or the right endpoint of the interval ending there) also has overlap count $$k$$.

More formally, define $$f(x)$$ as the number of intervals overlapping point $$x$$. The function $$f$$ is a step function that changes only at interval endpoints. If $$f(p) = k$$ is the maximum, and $$p$$ is strictly between two consecutive endpoints $$a$$ and $$b$$, then $$f(x) = k$$ for all $$x \in (a, b)$$. Thus, $$f(a) = k$$ or $$f(b) = k$$, so there exists an endpoint with maximum overlap.

### B.

Following the hint, maintain a red-black tree of all endpoints, where each endpoint $$e$$ has:
- $$e.point$$: the coordinate on the real line
- $$e.value$$: $$+1$$ if it's a left endpoint, $$-1$$ if it's a right endpoint

Augment each node $$x$$ with:
- $$x.delta$$: the sum of all values in the subtree rooted at $$x$$ (i.e., $$\sum \text{values in subtree}$$)
- $$x.max\_ending$$: the maximum cumulative sum achievable at any endpoint in the subtree rooted at $$x$$, where cumulative sum at a node is the sum of all values from the leftmost endpoint up to that node

For a node $$x$$ with left child $$l$$ and right child $$r$$:

$$\begin{align*}
x.delta &= l.delta + x.value + r.delta \\
x.max\_ending &= \max(l.max\_ending, l.delta + x.value + r.max\_ending)
\end{align*}$$

Wait, that's not quite right. Let me reconsider.

Actually, we want to track the maximum cumulative sum. Define:
- $$x.prefix\_sum$$: cumulative sum of all endpoints from the start up to and including $$x$$
- $$x.max\_pom$$: maximum cumulative sum in the subtree rooted at $$x$$

The $$prefix\_sum$$ at any point tells us how many intervals overlap at that point. We want to find the maximum $$prefix\_sum$$.

For a node $$x$$:

$$\begin{align*}
x.delta &= l.delta + x.value + r.delta \\
x.max\_pom &= \max(l.max\_pom, l.delta + x.value, l.delta + x.value + r.max\_pom)
\end{align*}$$

This simplifies to:

$$x.max\_pom = \max(l.max\_pom, l.delta + x.value + \max(0, r.max\_pom))$$

Actually, let me think more carefully. The cumulative sum increases by $$l.delta$$ as we traverse the left subtree, then by $$x.value$$ at node $$x$$, then by various amounts in the right subtree. The maximum in the right subtree is $$r.max\_pom$$, but it's relative to the start of the right subtree. Relative to the overall start, it's $$l.delta + x.value + r.max\_pom$$.

So:

$$x.max\_pom = \max(l.max\_pom, l.delta + x.value, l.delta + x.value + r.max\_pom)$$

{% include ads.html %}

### Operations

**$$\textsc{Find-POM}(T)$$:** Return $$T.root.max\_pom$$ in $$O(1)$$ time. This gives the maximum overlap count. To find the actual point, we can traverse the tree looking for a node where the cumulative sum equals $$max\_pom$$.

**$$\textsc{Interval-Insert}(T, [a, b])$$:**
1. Insert endpoint $$a$$ with value $$+1$$ into the tree
2. Insert endpoint $$b$$ with value $$-1$$ into the tree
3. Update $$delta$$ and $$max\_pom$$ attributes along paths to root
4. Handle rotations during fixup

Time: $$O(\lg n)$$

**$$\textsc{Interval-Delete}(T, [a, b])$$:**
1. Delete endpoint $$a$$ from the tree
2. Delete endpoint $$b$$ from the tree
3. Update attributes along paths to root

Time: $$O(\lg n)$$

The attributes satisfy Theorem 14.1 (each depends only on local information), so they can be maintained efficiently during tree modifications.

### Finding the Actual Point

To find not just the count but the actual point of maximum overlap:

{% capture code %}
Find-POM-Point(T)
    x = T.root
    cumsum = 0
    max_pom = T.root.max_pom

    while x != T.nil
        if x.left != T.nil and x.left.max_pom == max_pom
            x = x.left
        elseif cumsum + x.left.delta + x.value == max_pom
            return x.point
        else
            cumsum = cumsum + x.left.delta + x.value
            x = x.right
{% endcapture %}
{% include clrs_code.html title="Find-POM-Point(T)" %}

This traverses the tree following the path where the maximum is achieved, taking $$O(\lg n)$$ time.

All operations run in $$O(\lg n)$$ time.
